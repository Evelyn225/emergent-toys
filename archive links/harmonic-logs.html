<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harmonic Logs Database</title>
    <style>
        body {
            background: #0a0e1a;
            color: #c7d3e8;
            font-family: 'Courier New', monospace;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            line-height: 1.7;
        }
        h1 {
            color: #88aaff;
            border-bottom: 2px solid #334466;
            padding-bottom: 0.5rem;
        }
        h2 {
            color: #aaccff;
            margin-top: 2rem;
        }
        .entry {
            background: #0f1420;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 3px solid #4488ff;
        }
        .frequency {
            color: #88ffaa;
            font-weight: bold;
        }
        .audio-controls {
            margin: 1rem 0;
            padding: 0.8rem;
            background: rgba(68, 136, 255, 0.1);
            border-radius: 2px;
            display: inline-block;
        }
        .play-btn {
            padding: 0.5rem 1rem;
            background: #4488ff;
            color: #0a0e1a;
            border: none;
            border-radius: 2px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            margin-right: 0.5rem;
        }
        .play-btn:hover {
            background: #88aaff;
        }
        .status {
            color: #88ffaa;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <h1>Harmonic Logs Database</h1>
    <p><em>Spectral analysis of ambient system harmonics</em></p>

    <h2>Introduction</h2>
    <p>
        Every system produces harmonics. Most are discarded as noise. This archive preserves them. 
        What we call silence is actually a symphony we haven't learned to hear yet.
    </p>

    <h2>Notable Recordings</h2>

    <div class="entry">
        <strong>Entry #0047</strong><br>
        <span class="frequency">Frequency: 47.3 Hz</span><br>
        Duration: 11 hours<br>
        <p>
            Server closet ambient recording. Base frequency remains constant despite fan speed variations. 
            Spectral analysis reveals underlying pattern matching Fibonacci sequence when mapped to musical intervals.
        </p>
        <div class="audio-controls">
            <button class="play-btn" onclick="playHarmonic(47.3, this)">▶ Play (47.3 Hz)</button>
            <span class="status">Server closet hum</span>
        </div>
    </div>

    <div class="entry">
        <strong>Entry #0189</strong><br>
        <span class="frequency">Frequency: Variable (120-180 Hz)</span><br>
        Duration: 3.5 hours<br>
        <p>
            Nocturnal recording during low activity period. System produces harmonics that weren't present 
            during high-load hours. Pattern suggests the network "relaxes" when not under observation.
        </p>
        <div class="audio-controls">
            <button class="play-btn" onclick="playVariableFreq(120, 180, this)">▶ Play (120-180 Hz)</button>
            <span class="status">Nocturnal harmonics</span>
        </div>
    </div>

    <div class="entry">
        <strong>Entry #0234</strong><br>
        <span class="frequency">Frequency: 432 Hz</span><br>
        Duration: Ongoing<br>
        <p>
            Persistent tone of unknown origin. Not produced by any identifiable hardware component. 
            Exists only when all measured sounds are subtracted from total ambient recording. 
            The sound of what remains when everything else is removed.
        </p>
        <div class="audio-controls">
            <button class="play-btn" onclick="playHarmonic(432, this)">▶ Play (432 Hz)</button>
            <span class="status">Unknown persistent tone</span>
        </div>
    </div>

    <div class="entry">
        <strong>Entry #0356</strong><br>
        <span class="frequency">Frequency: 256 Hz</span><br>
        Duration: 7.2 hours<br>
        <p>
            Deep subsonic resonance detected during high-capacity data transfer events. 
            Appears to correspond with peak network throughput. When mapped to spectrogram, 
            creates a pattern resembling crystalline growth formations.
        </p>
        <div class="audio-controls">
            <button class="play-btn" onclick="playHarmonic(256, this)">▶ Play (256 Hz)</button>
            <span class="status">Data flow resonance</span>
        </div>
    </div>

    <div class="entry">
        <strong>Entry #0442</strong><br>
        <span class="frequency">Frequency: 144 Hz (Primary), 288 Hz (Harmonic)</span><br>
        Duration: 5.8 hours<br>
        <p>
            Dual-harmonic signature detected in morning hour surge traffic. Primary frequency remains stable 
            while harmonic doubles in amplitude. Suggests two independent systems vibrating in sympathetic resonance. 
            Mathematical relationship mirrors golden ratio proportions.
        </p>
        <div class="audio-controls">
            <button class="play-btn" onclick="playDualHarmonic(144, 288, this)">▶ Play (144 + 288 Hz)</button>
            <span class="status">Sympathetic harmonics</span>
        </div>
    </div>

    <h2>Analysis Methods</h2>
    <p>
        Recordings are processed through:
    </p>
    <ul>
        <li>Fast Fourier Transform (FFT) for frequency decomposition</li>
        <li>Pattern matching against known mathematical sequences</li>
        <li>Correlation analysis with system event logs</li>
        <li>Meditation (unexpectedly effective)</li>
    </ul>

    <h2>Findings</h2>
    <p>
        Harmonics appear to encode information about system state before the state manifests. 
        The network knows what it's about to do 3-7 seconds before it does it. The harmonics are 
        the sound of the future leaking into the present.
    </p>

    <p style="margin-top: 3rem; opacity: 0.6; font-size: 0.9em;">
        Last updated: [LISTENING]<br>
        Total entries: 847
    </p>

    <script>
        let currentOscillators = [];
        let audioContext = null;
        let interferenceBuffer = null;
        let interferenceLoaded = false;

        // Load interference audio on first user interaction
        async function loadInterferenceAudio() {
            if (interferenceLoaded) return;
            interferenceLoaded = true;
            
            try {
                const response = await fetch('audio/interference.mp3');
                if (!response.ok) throw new Error('Failed to fetch interference audio');
                const arrayBuffer = await response.arrayBuffer();
                
                // Try to decode the audio
                try {
                    interferenceBuffer = await audioContext.decodeAudioData(arrayBuffer);
                } catch (decodeError) {
                    // MP3 might not be supported
                    console.log('MP3 decode failed:', decodeError);
                    interferenceBuffer = null;
                }
            } catch (e) {
                console.log('Could not load interference audio:', e);
                interferenceBuffer = null;
            }
        }

        function getAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioContext;
        }

        function stopAllSounds() {
            currentOscillators.forEach(osc => {
                try {
                    osc.stop(getAudioContext().currentTime + 0.1);
                } catch (e) {}
            });
            currentOscillators = [];
        }

        function playInterferenceSnippet(ctx) {
            if (!interferenceBuffer || !ctx) return;

            const now = ctx.currentTime;
            const duration = interferenceBuffer.duration;
            
            // Random start point in the audio file
            const startTime = Math.random() * Math.max(0, duration - 0.5);
            const snippetDuration = Math.min(0.3 + Math.random() * 0.4, duration - startTime);

            try {
                const source = ctx.createBufferSource();
                source.buffer = interferenceBuffer;
                
                // Create filter for radio effect
                const filter = ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 2000 + Math.random() * 3000;
                filter.Q.value = 0.5;
                
                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + snippetDuration);
                
                source.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                
                source.start(now, startTime, snippetDuration);
                source.stop(now + snippetDuration);
            } catch (e) {
                console.log('Error playing interference snippet:', e);
            }
        }

        function playHarmonic(frequency, button) {
            const ctx = getAudioContext();
            stopAllSounds();
            
            if (button.textContent.includes('■')) {
                button.textContent = button.textContent.replace('■', '▶');
                return;
            }

            // Load interference on first play
            if (!interferenceLoaded) {
                loadInterferenceAudio();
            }

            const oscillators = [];
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.2, ctx.currentTime);
            gain.connect(ctx.destination);

            // Primary frequency
            const osc = ctx.createOscillator();
            osc.frequency.value = frequency;
            osc.type = 'sine';
            osc.connect(gain);
            osc.start(ctx.currentTime);
            oscillators.push(osc);

            // Add subtle harmonics for richness
            [frequency * 2, frequency * 0.5].forEach(freq => {
                const harmOsc = ctx.createOscillator();
                harmOsc.frequency.value = freq;
                harmOsc.type = 'sine';
                const harmGain = ctx.createGain();
                harmGain.gain.value = 0.08;
                harmGain.connect(ctx.destination);
                harmOsc.connect(harmGain);
                harmOsc.start(ctx.currentTime);
                oscillators.push(harmOsc);
            });

            // Rare interference snippets from recorded audio
            if (interferenceBuffer) {
                const interferenceInterval = setInterval(() => {
                    const playingBtn = document.querySelector('.play-btn[style*="background: rgb(255, 68, 136)"]');
                    if (!playingBtn) {
                        clearInterval(interferenceInterval);
                        return;
                    }
                    
                    // 5% chance every 2 seconds
                    if (Math.random() < 0.05) {
                        playInterferenceSnippet(ctx);
                    }
                }, 2000);
                
                oscillators.push({ interval: interferenceInterval });
            }

            currentOscillators = oscillators;
            button.textContent = button.textContent.replace('▶', '■');
            button.style.background = '#ff4488';
        }

        function playVariableFreq(minFreq, maxFreq, button) {
            const ctx = getAudioContext();
            stopAllSounds();
            
            if (button.textContent.includes('■')) {
                button.textContent = button.textContent.replace('■', '▶');
                return;
            }

            // Load interference on first play
            if (!interferenceLoaded) {
                loadInterferenceAudio();
            }

            const oscillators = [];
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.2, ctx.currentTime);
            gain.connect(ctx.destination);

            const osc = ctx.createOscillator();
            osc.frequency.setValueAtTime(minFreq, ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(maxFreq, ctx.currentTime + 4);
            osc.type = 'sine';
            osc.connect(gain);
            osc.start(ctx.currentTime);
            oscillators.push(osc);

            // Rare interference snippets
            if (interferenceBuffer) {
                const interferenceInterval = setInterval(() => {
                    const playingBtn = document.querySelector('.play-btn[style*="background: rgb(255, 68, 136)"]');
                    if (!playingBtn) {
                        clearInterval(interferenceInterval);
                        return;
                    }
                    
                    if (Math.random() < 0.05) {
                        playInterferenceSnippet(ctx);
                    }
                }, 2000);
                
                oscillators.push({ interval: interferenceInterval });
            }

            currentOscillators = oscillators;
            button.textContent = button.textContent.replace('▶', '■');
            button.style.background = '#ff4488';

            setTimeout(() => {
                if (currentOscillators === oscillators) {
                    stopAllSounds();
                    button.textContent = button.textContent.replace('■', '▶');
                    button.style.background = '#4488ff';
                }
            }, 4000);
        }

        function playDualHarmonic(freq1, freq2, button) {
            const ctx = getAudioContext();
            stopAllSounds();
            
            if (button.textContent.includes('■')) {
                button.textContent = button.textContent.replace('■', '▶');
                return;
            }

            // Load interference on first play
            if (!interferenceLoaded) {
                loadInterferenceAudio();
            }

            const oscillators = [];
            
            // First harmonic
            const gain1 = ctx.createGain();
            gain1.gain.setValueAtTime(0.15, ctx.currentTime);
            gain1.connect(ctx.destination);
            const osc1 = ctx.createOscillator();
            osc1.frequency.value = freq1;
            osc1.type = 'sine';
            osc1.connect(gain1);
            osc1.start(ctx.currentTime);
            oscillators.push(osc1);

            // Second harmonic
            const gain2 = ctx.createGain();
            gain2.gain.setValueAtTime(0.12, ctx.currentTime);
            gain2.connect(ctx.destination);
            const osc2 = ctx.createOscillator();
            osc2.frequency.value = freq2;
            osc2.type = 'sine';
            osc2.connect(gain2);
            osc2.start(ctx.currentTime);
            oscillators.push(osc2);

            // Rare interference snippets
            if (interferenceBuffer) {
                const interferenceInterval = setInterval(() => {
                    const playingBtn = document.querySelector('.play-btn[style*="background: rgb(255, 68, 136)"]');
                    if (!playingBtn) {
                        clearInterval(interferenceInterval);
                        return;
                    }
                    
                    if (Math.random() < 0.05) {
                        playInterferenceSnippet(ctx);
                    }
                }, 2000);
                
                oscillators.push({ interval: interferenceInterval });
            }

            currentOscillators = oscillators;
            button.textContent = button.textContent.replace('▶', '■');
            button.style.background = '#ff4488';
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', stopAllSounds);
    </script></body>
</html>
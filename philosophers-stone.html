<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/favicon-16x16.png">
  <link rel="manifest" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/site.webmanifest">
  <title>Philosopher's Stone - Reaction-Diffusion Particles</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: 'Inter', sans-serif;
    }
    canvas {
      display: block;
    }
    #controls {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      padding: 15px;
      color: #fff;
      font-size: 12px;
      z-index: 100;
      max-width: 250px;
    }
    .control-group {
      margin-bottom: 10px;
    }
    label {
      display: block;
      margin-bottom: 3px;
      color: #aaa;
    }
    input[type="range"] {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: #333;
      border-radius: 3px;
      outline: none;
      cursor: pointer;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: rgba(100, 150, 200, 0.9);
      cursor: pointer;
      border: 1px solid rgba(100, 150, 200, 1);
    }
    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: rgba(100, 150, 200, 0.9);
      cursor: pointer;
      border: 1px solid rgba(100, 150, 200, 1);
    }
    input[type="range"]::-moz-range-track {
      background: transparent;
      border: none;
    }
    button {
      width: 100%;
      padding: 6px;
      background: rgba(100, 150, 200, 0.5);
      border: 1px solid rgba(100, 150, 200, 0.8);
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.2s;
    }
    button:hover {
      background: rgba(100, 150, 200, 0.7);
    }
    #info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      padding: 12px;
      color: #aaa;
      font-size: 11px;
      max-width: 300px;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <a href="index.html" style="position: fixed; top: 20px; right: 20px; z-index: 101; padding: 10px 14px; background: rgba(0, 0, 0, 0.8); color: white; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 8px; text-decoration: none; font-family: 'Inter', sans-serif; font-size: 18px; transition: all 0.2s; line-height: 1;">üè†</a>
  <canvas id="canvas"></canvas>
  <div id="controls">
    <div class="control-group">
      <label>Particle Count: <span id="particleCount">500</span> (10-1000)</label>
      <input type="range" id="particleSlider" min="10" max="1000" value="500">
    </div>
    <div class="control-group">
      <label>Particle Speed: <span id="speedValue">1.0</span> (0.1-3.0)</label>
      <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1.0">
    </div>
    <div class="control-group">
      <label>Diffusion Rate: <span id="diffusionValue">0.25</span> (0.05-0.5)</label>
      <input type="range" id="diffusionSlider" min="0.05" max="0.5" step="0.05" value="0.25">
    </div>
    <div class="control-group">
      <label>Reaction Rate: <span id="reactionValue">0.10</span> (0.01-0.9)</label>
      <input type="range" id="reactionSlider" min="0.01" max="0.9" step="0.01" value="0.1">
    </div>
    <div class="control-group">
      <label>Trail Decay: <span id="decayValue">0.950</span> (0.85-0.999)</label>
      <input type="range" id="decaySlider" min="0.85" max="0.999" step="0.001" value="0.95">
    </div>
    <button id="resetBtn">Reset</button>
  </div>
  <div id="info">
    <strong>Philosopher's Stone</strong><br>
    Click and drag to add particles. Particles leave trails (Chemical B) that react with particles (Chemical A), creating emergent patterns.<br><br>
    <strong>Controls:</strong><br>
    ‚Ä¢ Click/Drag to spawn particles<br>
    ‚Ä¢ Shift+Click for anti-particles<br>
    ‚Ä¢ Adjust parameters to explore different behaviors
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const gridResolution = 4;
    const gridWidth = Math.ceil(canvas.width / gridResolution);
    const gridHeight = Math.ceil(canvas.height / gridResolution);
    
    let gridA = Array(gridWidth * gridHeight).fill(0);
    let gridB = Array(gridWidth * gridHeight).fill(0);
    let gridA_next = Array(gridWidth * gridHeight).fill(0);
    let gridB_next = Array(gridWidth * gridHeight).fill(0);
    let params = {
      particleCount: 500,
      speed: 1.0,
      diffusionA: 0.16,
      diffusionB: 0.05,
      feedRate: 0.055,
      killRate: 0.062,
      decayRate: 0.999,
      speedMultiplier: 1.0,
      reactionRate: 0.10
    };

    class Particle {
      constructor(x, y, isAnti = false) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
        this.angle = Math.random() * Math.PI * 2;
        this.isAnti = isAnti;
        this.hue = Math.random() * 360;
        this.trailSize = isAnti ? 0.5 : 1;
      }

      update() {
        const gridX = Math.floor(this.x / gridResolution);
        const gridY = Math.floor(this.y / gridResolution);
        
        const sensorDistance = 10 + (params.reactionRate * 25);
        let bestAngle = this.angle;
        let bestValue = -Infinity;

        for (let offset = -Math.PI / 4; offset <= Math.PI / 4; offset += Math.PI / 4) {
          const senseAngle = this.angle + offset;
          const sx = Math.floor((this.x + Math.cos(senseAngle) * sensorDistance) / gridResolution);
          const sy = Math.floor((this.y + Math.sin(senseAngle) * sensorDistance) / gridResolution);
          
          if (sx >= 0 && sx < gridWidth && sy >= 0 && sy < gridHeight) {
            const idx = sx + sy * gridWidth;
            let value = gridB[idx];
            
            if (this.isAnti) {
              value = -value;
              if (gridB[idx] > 0) {
                value -= gridB[idx] * params.reactionRate * 8;
              }
            } else {
              if (gridB[idx] < 0) {
                value -= (-gridB[idx]) * params.reactionRate * 8;
              }
            }
            
            if (value > bestValue) {
              bestValue = value;
              bestAngle = senseAngle;
            }
          }
        }

        const clusteringThreshold = params.reactionRate;
        
        if (bestValue > 0.001) {
          let steeringStrength;
          
          if (clusteringThreshold < 0.15) {
            steeringStrength = Math.min(0.15, Math.pow(bestValue, 2.5) * 1);
          } else if (clusteringThreshold < 0.35) {
            steeringStrength = Math.min(0.5, Math.pow(bestValue, 1.5) * 2.5);
          } else {
            steeringStrength = Math.min(0.8, Math.pow(bestValue, 1.3) * 4);
          }
          
          this.angle += (bestAngle - this.angle) * steeringStrength;
        } else {
          const wanderStrength = clusteringThreshold < 0.15 ? 0.8 : 0.3;
          this.angle += (Math.random() - 0.5) * wanderStrength;
        }

        this.x += Math.cos(this.angle) * params.speed * params.speedMultiplier;
        this.y += Math.sin(this.angle) * params.speed * params.speedMultiplier;
        if (this.x < 0) this.x += canvas.width;
        if (this.x >= canvas.width) this.x -= canvas.width;
        if (this.y < 0) this.y += canvas.height;
        if (this.y >= canvas.height) this.y -= canvas.height;
      }

      deposit() {
        const gridX = Math.floor(this.x / gridResolution);
        const gridY = Math.floor(this.y / gridResolution);
        
        if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
          const idx = gridX + gridY * gridWidth;
          const currentTrail = gridB[idx];
          const depositAmount = this.isAnti ? -this.trailSize : this.trailSize;
          
          let consumedTrail = currentTrail;
          
          if ((this.isAnti && currentTrail > 0) || (!this.isAnti && currentTrail < 0)) {
            const consumptionRate = params.reactionRate * 2;
            const consumed = Math.abs(currentTrail) * consumptionRate;
            consumedTrail = currentTrail + Math.sign(depositAmount) * consumed;
          }
          
          const newTrail = consumedTrail + depositAmount * 0.5;
          gridB[idx] = Math.max(-1, Math.min(1, newTrail));
        }
      }

      draw() {
        if (this.isAnti) {
          ctx.fillStyle = `hsla(${this.hue}, 100%, 50%, 0.6)`;
        } else {
          ctx.fillStyle = `hsla(${this.hue}, 100%, 60%, 0.7)`;
        }
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    let particles = [];

    function initializeParticles() {
      particles = [];
      for (let i = 0; i < params.particleCount; i++) {
        particles.push(new Particle(
          Math.random() * canvas.width,
          Math.random() * canvas.height,
          Math.random() < 0.45
        ));
      }
    }

    function diffuseGrid() {
      for (let y = 1; y < gridHeight - 1; y++) {
        for (let x = 1; x < gridWidth - 1; x++) {
          const idx = x + y * gridWidth;
          
          const b = gridB[idx];
          const bNeighbors = 
            gridB[(x-1) + y * gridWidth] +
            gridB[(x+1) + y * gridWidth] +
            gridB[x + (y-1) * gridWidth] +
            gridB[x + (y+1) * gridWidth];
          
          gridB_next[idx] = b + (bNeighbors / 4 - b) * params.diffusionB;
        }
      }

      [gridB, gridB_next] = [gridB_next, gridB];
    }

    function computeReaction() {
      for (let i = 0; i < gridB.length; i++) {
        gridB[i] *= params.decayRate;
      }
    }

    function updateSimulation() {
      for (let p of particles) {
        p.update();
        p.deposit();
      }

      diffuseGrid();
      computeReaction();
    }

    function render() {
      const imageData = ctx.createImageData(canvas.width, canvas.height);
      const data = imageData.data;

      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          const idx = x + y * gridWidth;
          const b = gridB[idx];
          
          let r = 0, g = 0, bl = 0;
          
          if (b > 0) {
            r = Math.floor(b * 100);
            g = Math.floor(b * 200 + 50);
            bl = Math.floor(b * 255);
          } else if (b < 0) {
            r = Math.floor(-b * 255);
            g = Math.floor(-b * 100);
            bl = Math.floor(-b * 200);
          }
          for (let dy = 0; dy < gridResolution; dy++) {
            for (let dx = 0; dx < gridResolution; dx++) {
              const px = x * gridResolution + dx;
              const py = y * gridResolution + dy;
              const pixelIdx = (py * canvas.width + px) * 4;
              
              if (pixelIdx >= 0 && pixelIdx < data.length) {
                data[pixelIdx] = r;
                data[pixelIdx + 1] = g;
                data[pixelIdx + 2] = bl;
                data[pixelIdx + 3] = 255;
              }
            }
          }
        }
      }

      ctx.putImageData(imageData, 0, 0);

      for (let p of particles) {
        p.draw();
      }
    }

    function animate() {
      updateSimulation();
      render();
      requestAnimationFrame(animate);
    }

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      const newGridWidth = Math.ceil(canvas.width / gridResolution);
      const newGridHeight = Math.ceil(canvas.height / gridResolution);
      
      if (newGridWidth !== gridWidth || newGridHeight !== gridHeight) {
        window.location.reload();
      }
    });

    canvas.addEventListener('click', (e) => {
      const isAnti = e.shiftKey;
      for (let i = 0; i < 5; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * 20;
        particles.push(new Particle(
          e.clientX + Math.cos(angle) * dist,
          e.clientY + Math.sin(angle) * dist,
          isAnti
        ));
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (e.buttons & 1) {
        particles.push(new Particle(
          e.clientX + (Math.random() - 0.5) * 10,
          e.clientY + (Math.random() - 0.5) * 10,
          e.shiftKey
        ));
      }
      if (e.buttons & 2) {
        particles.push(new Particle(
          e.clientX + (Math.random() - 0.5) * 10,
          e.clientY + (Math.random() - 0.5) * 10,
          true
        ));
      }
    });

    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      for (let i = 0; i < 5; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * 20;
        particles.push(new Particle(
          e.clientX + Math.cos(angle) * dist,
          e.clientY + Math.sin(angle) * dist,
          true
        ));
      }
    });

    document.getElementById('particleSlider').addEventListener('input', (e) => {
      const newCount = parseInt(e.target.value);
      const oldCount = particles.length;
      document.getElementById('particleCount').textContent = newCount;
      
      if (newCount > oldCount) {
        for (let i = 0; i < newCount - oldCount; i++) {
          particles.push(new Particle(
            Math.random() * canvas.width,
            Math.random() * canvas.height,
            Math.random() < 0.25
          ));
        }
      } else if (newCount < oldCount) {
        particles = particles.slice(0, newCount);
      }
      params.particleCount = newCount;
    });

    document.getElementById('speedSlider').addEventListener('input', (e) => {
      params.speedMultiplier = parseFloat(e.target.value);
      document.getElementById('speedValue').textContent = params.speedMultiplier.toFixed(1);
    });

    document.getElementById('diffusionSlider').addEventListener('input', (e) => {
      params.diffusionB = parseFloat(e.target.value);
      document.getElementById('diffusionValue').textContent = params.diffusionB.toFixed(2);
    });

    document.getElementById('reactionSlider').addEventListener('input', (e) => {
      params.reactionRate = parseFloat(e.target.value);
      document.getElementById('reactionValue').textContent = params.reactionRate.toFixed(2);
    });

    document.getElementById('decaySlider').addEventListener('input', (e) => {
      params.decayRate = parseFloat(e.target.value);
      document.getElementById('decayValue').textContent = params.decayRate.toFixed(3);
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      gridA.fill(0);
      gridB.fill(0);
      particles = [];
      initializeParticles();
    });

    function initializeControls() {
      document.getElementById('particleSlider').value = 500;
      document.getElementById('speedSlider').value = 1.0;
      document.getElementById('diffusionSlider').value = 0.25;
      document.getElementById('reactionSlider').value = 0.10;
      document.getElementById('decaySlider').value = 0.950;
      
      document.getElementById('particleCount').textContent = 500;
      document.getElementById('speedValue').textContent = (1.0).toFixed(1);
      document.getElementById('diffusionValue').textContent = (0.25).toFixed(2);
      document.getElementById('reactionValue').textContent = (0.10).toFixed(2);
      document.getElementById('decayValue').textContent = (0.950).toFixed(3);
      
      params.particleCount = 500;
      params.speedMultiplier = 1.0;
      params.diffusionB = 0.25;
      params.reactionRate = 0.10;
      params.decayRate = 0.950;
    }
    
    initializeControls();
    initializeParticles();
    animate();
  </script>
</body>
</html>

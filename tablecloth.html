<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/favicon-16x16.png">
    <link rel="manifest" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/site.webmanifest">
    <title>Warping Tablecloth Pattern</title>
    <style>
        body {
            background-image: url('https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/tiles_bg.jpg');
            background-repeat: repeat;
            margin: 0;
            overflow: hidden;
            background-color: #f5f0e8;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        canvas {
            border: 1px solid #ccc;
            background: linear-gradient(135deg, #ffffff 0%, #f8f6f1 100%);
            max-width: 95vw;
            height: auto;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
            cursor: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Base canvas size (logical) and responsive scaling
        const baseSize = { width: 1200, height: 700 };
        let logicalWidth = baseSize.width;
        let logicalHeight = baseSize.height;

        function resizeCanvas() {
            const maxW = window.innerWidth * 0.95;
            const maxH = window.innerHeight * 0.9;
            const scale = Math.min(maxW / baseSize.width, maxH / baseSize.height, 1);
            logicalWidth = Math.round(baseSize.width * scale);
            logicalHeight = Math.round(baseSize.height * scale);

            const dpr = window.devicePixelRatio || 1;
            canvas.style.width = `${logicalWidth}px`;
            canvas.style.height = `${logicalHeight}px`;
            canvas.width = Math.round(logicalWidth * dpr);
            canvas.height = Math.round(logicalHeight * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            // no cached background; everything is redrawn each frame
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Pattern configuration
        const config = {
            gridSize: 28,
            warpAmplitude: 18,
            warpFrequency: 0.02,
            color: '#0c0c0c',
            accentColor: '#0c0c0c',
            timeSpeed: 0.008,
            lineWidth: 2
        };

        let time = 0;
        const ripples = [];
        let lastMousePos = { x: 0, y: 0, time: 0 };
        let mouseRippleCounter = 0;
        let mouseAngle = 0;
        let targetAngle = 0;
        let cursorImage = null;

        // Load custom cursor image
        const cursorImg = new Image();
        cursorImg.src = 'https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/paw.png?v=' + Date.now();
        cursorImg.onload = () => {
            cursorImage = cursorImg;
        };

        // Draw rotated cursor image on main canvas
        function drawCursor(x, y, angle) {
            if (!cursorImage) return;
            
            const size = 22; // Adjust size as needed
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.drawImage(cursorImage, -size / 2, -size / 2, size, size);
            ctx.restore();
        }

        function rippleDisplacement(x, y) {
            if (ripples.length === 0) return 0;
            let offset = 0;
            for (let i = 0; i < ripples.length; i++) {
                const r = ripples[i];
                const dx = x - r.x;
                const dy = y - r.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const wave = Math.sin((dist - r.t * 120) / 10);
                const falloff = Math.exp(-dist / 220);
                const fade = Math.max(0, 1 - r.t / 1.4);
                const ease = fade * fade * (3 - 2 * fade);
                const strength = r.strength !== undefined ? r.strength : 1.0;
                offset += wave * falloff * 6 * ease * strength;
            }
            return offset;
        }

        function drawWarpedGrid() {
            // Base fill
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, logicalWidth, logicalHeight);

            ctx.strokeStyle = config.color;
            ctx.lineWidth = config.lineWidth;
            ctx.lineCap = 'round';

            const t = time * 2;
            const freq = config.warpFrequency;
            const amp = config.warpAmplitude;
            ctx.globalAlpha = 0.85;
            const drawW = logicalWidth + config.gridSize;
            const drawH = logicalHeight + config.gridSize;

            // Red/white check pattern that follows the warp + ripples
            const block = config.gridSize * 3.02; // Slightly larger to better match visual grid spacing
            ctx.globalAlpha = 0.95;
            // Start at grid-aligned positions
            const startY = Math.floor(-block / config.gridSize) * config.gridSize;
            const startX = Math.floor(-block / config.gridSize) * config.gridSize;
            for (let y = startY; y <= logicalHeight + block; y += block) {
                for (let x = startX; x <= logicalWidth + block; x += block) {
                    const isRed = (Math.floor(x / block) + Math.floor(y / block)) % 2 === 0;
                    ctx.fillStyle = isRed ? '#C94B4B' : '#FFFFFF';

                    // Match exact grid line displacement
                    const r1 = rippleDisplacement(x, y);
                    const r2 = rippleDisplacement(x + block, y);
                    const r3 = rippleDisplacement(x + block, y + block);
                    const r4 = rippleDisplacement(x, y + block);

                    // X warps based on Y position (vertical lines), Y warps based on X position (horizontal lines)
                    const x1 = x + Math.sin(y * freq + t) * amp + r1;
                    const y1 = y + Math.sin(x * freq + t) * amp + r1;
                    const x2 = (x + block) + Math.sin(y * freq + t) * amp + r2;
                    const y2 = y + Math.sin((x + block) * freq + t) * amp + r2;
                    const x3 = (x + block) + Math.sin((y + block) * freq + t) * amp + r3;
                    const y3 = (y + block) + Math.sin((x + block) * freq + t) * amp + r3;
                    const x4 = x + Math.sin((y + block) * freq + t) * amp + r4;
                    const y4 = (y + block) + Math.sin(x * freq + t) * amp + r4;

                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x3, y3);
                    ctx.lineTo(x4, y4);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // Draw horizontal lines (warp)
            ctx.globalAlpha = 0.85;
            ctx.strokeStyle = config.color;
            ctx.lineWidth = config.lineWidth;
            for (let y = -config.gridSize; y <= drawH; y += config.gridSize) {
                ctx.beginPath();
                for (let x = -config.gridSize; x <= drawW; x += 15) {
                    const ripple = rippleDisplacement(x, y);
                    const warpY = y + Math.sin(x * freq + t) * amp + ripple;
                    if (x === 0) {
                        ctx.moveTo(x, warpY);
                    } else {
                        ctx.lineTo(x, warpY);
                    }
                }
                ctx.stroke();
            }

            // Draw vertical lines (weft)
            for (let x = -config.gridSize; x <= drawW; x += config.gridSize) {
                ctx.beginPath();
                for (let y = -config.gridSize; y <= drawH; y += 15) {
                    const ripple = rippleDisplacement(x, y);
                    const warpX = x + Math.sin(y * freq + t) * amp + ripple;
                    if (y === 0) {
                        ctx.moveTo(warpX, y);
                    } else {
                        ctx.lineTo(warpX, y);
                    }
                }
                ctx.stroke();
            }

            // Draw ripple interactions
            if (ripples.length > 0) {
                ctx.strokeStyle = config.accentColor;
                ctx.lineWidth = 1.5;
                for (let i = ripples.length - 1; i >= 0; i--) {
                    const r = ripples[i];
                    
                    // Draw visible circles for click ripples
                    if (r.type === 'click') {
                        const radius = r.t * 120;
                        const fade = Math.max(0, 1 - r.t / 1.4);
                        const ease = fade * fade * (3 - 2 * fade);
                        const alpha = 0.55 * ease;
                        ctx.globalAlpha = alpha;
                        ctx.beginPath();
                        ctx.arc(r.x, r.y, radius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    r.t += 0.015;
                    if (r.t > 1.4) {
                        ripples.splice(i, 1);
                    }
                }
                ctx.globalAlpha = 1;
            }

            // Draw paw cursor
            if (lastMousePos.x > 0 || lastMousePos.y > 0) {
                drawCursor(lastMousePos.x, lastMousePos.y, mouseAngle);
            }

            time += config.timeSpeed;
            requestAnimationFrame(drawWarpedGrid);
        }

        // Start animation
        drawWarpedGrid();
        // Mouse interactivity - simple and performant
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width * logicalWidth;
            const y = (e.clientY - rect.top) / rect.height * logicalHeight;

            // Create subtle ripples as mouse moves
            const now = Date.now();
            const dx = x - lastMousePos.x;
            const dy = y - lastMousePos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const timeDelta = now - lastMousePos.time;

            // Update cursor angle based on movement direction
            if (dx !== 0 || dy !== 0) {
                targetAngle = Math.atan2(dy, dx) + Math.PI / 2; // Add 90 degrees so paw points forward
            }

            // Smoothly interpolate towards target angle
            let angleDiff = targetAngle - mouseAngle;
            // Normalize angle difference to shortest path
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            mouseAngle += angleDiff * 0.15; // Smooth easing (adjust 0.15 for faster/slower rotation)

            // Create ripple on every mouse movement with some speed
            if (dist > 3 && timeDelta > 16) { // ~60fps polling
                // Scale strength with mouse speed (dist/timeDelta)
                const speed = dist / Math.max(timeDelta, 1);
                const strength = Math.min(0.5, 0.1 + speed * 0.05); // 0.1 to 0.5 range
                ripples.push({ x, y, t: 0, strength: strength, type: 'mousemove' }); // subtler, no circle
                lastMousePos = { x, y, time: now };
            }
        });
        canvas.addEventListener('mouseleave', () => {
            config.warpAmplitude = 18;
            config.warpFrequency = 0.02;
        });
        // Click to create ripples
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width * logicalWidth;
            const y = (e.clientY - rect.top) / rect.height * logicalHeight;
            ripples.push({ x, y, t: 0, strength: 1.0, type: 'click' });
        });
        // Double-click to reset
        canvas.addEventListener('dblclick', () => {
            config.warpAmplitude = 18;
            config.warpFrequency = 0.02;
            time = 0;
        });
    </script>
</body>
</html> 
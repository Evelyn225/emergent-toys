<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/favicon-16x16.png">
    <link rel="manifest" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/site.webmanifest">
    <title>DOM Roulette</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            min-height: 100vh;
            position: relative;
        }

        #regenerateButton {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #regenerateButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        #regenerateButton:active {
            transform: translateY(0);
        }

        #regenerateButton:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            font-size: 18px;
            color: #333;
        }

        #loadingText {
            white-space: pre-line;
            text-align: center;
        }

        #loadingOverlay.hidden {
            display: none;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #generatedContent {
            min-height: 100vh;
        }
    </style>
</head>
<body>
    <button id="regenerateButton">ðŸ”„ Regenerate Site</button>
    
    <div id="loadingOverlay">
        <div class="spinner"></div>
        <div id="loadingText">Generating your website...</div>
    </div>

    <div id="generatedContent"></div>

    <script>
        // API endpoints - uses Vercel serverless functions
        const RANDOM_WORDS_ENDPOINT = '/api/random-words.js';
        const GENERATE_ENDPOINT = '/api/generate.js';

        // Create the prompt for the AI
        function createGenerationPrompt(theme) {
            return `Generate a complete, self-contained HTML page inspired by: "${theme}"

INSTRUCTIONS - DO NOT EXPLAIN, ONLY OUTPUT CODE:
- Output ONLY valid HTML/CSS/JavaScript code
- Do NOT include any explanations, descriptions, or markdown
- Do NOT include <html>, <head>, or <body> tags
- Include all CSS in <style> tags and all JS in <script> tags
- The code must be complete, robust, and runnable as-is

DEPTH & COMPLEXITY REQUIREMENTS:
- Create a FULL, FLESHED-OUT experience, not a simple demo
- Implement multiple interactive layers and systems
- Include state management and persistent behavior
- Add visual polish with smooth animations and transitions
- Create depth through layering, parallax, or 3D effects
- Implement game-like mechanics if appropriate (scoring, progression, challenges)
- Add narrative or contextual elements that develop over time
- Include multiple interactive zones or sections
- Create emergent complexity where interactions combine in unexpected ways

VISUAL & DESIGN RICHNESS:
- Use gradients, shadows, filters, and effects extensively
- Implement animated backgrounds or dynamic lighting
- Create visual feedback for all interactions
- Use typography creatively - animate text, distort it, overlay it
- Build complex color palettes with intentional clashing
- Include decorative elements that serve no purpose but add richness
- Implement canvas/WebGL for advanced graphics if relevant
- Create visual hierarchies even in chaos

INTERACTIVITY DEPTH:
- Multiple interactive systems that work together
- Hover effects that are complex and layered
- Click handlers that trigger chains of events
- Keyboard input with multiple commands
- Mouse movement that affects multiple elements
- Randomized but coherent behaviors
- Hidden mechanics that reveal themselves
- Easter eggs and unexpected features

TECHNICAL DEPTH:
- Use requestAnimationFrame for smooth 60fps animations
- Implement particle systems, noise functions, or cellular automata
- Use external libraries effectively (p5.js, Three.js, Tone.js)
- Create custom algorithms for generative content
- Implement physics, collision detection, or advanced math
- Use WebGL shaders if doing advanced graphics
- Build audio synthesis or generative sound
- Create responsive, fullscreen experiences

CONTENT RICHNESS:
- Don't just have empty space - fill every pixel with something
- Add layered information and visual density
- Create multiple "levels" of interaction to discover
- Include surprising elements that reward exploration
- Build mini-games or sub-systems within the experience
- Add visual narratives or symbolic content
- Make the experience feel intentional and crafted, not random

MAKE IT SUBSTANTIAL - This should feel like a complete webpage or interactive work, not a rough sketch. Do NOT use any placeholders or "TODO" comments. do NOT output minimal or simplistic code.
The weirder AND more detailed, the better.

BEGIN OUTPUTTING THE COMPLETE HTML CODE NOW:`;
        }

        // Persona-specific loading messages
        const personaLoadingMessages = {
            "The Poet": [
                "ðŸŒ™ Weaving metaphors from starlight...",
                "âœ¨ Finding beauty in the space between words...",
                "ðŸ“œ Composing verses from digital dreams...",
                "ðŸŽ­ Sculpting meaning from the void..."
            ],
            "The Dadaist": [
                "ðŸŽª Dismantling logic, one byte at a time...",
                "ðŸŽ² Rolling dice in the void of reason...",
                "ðŸ”€ Shuffling reality like a deck of chaos...",
                "ðŸƒ Rejecting sense, embracing nonsense..."
            ],
            "The Surrealist": [
                "ðŸŒ€ Descending into the dream realm...",
                "ðŸŽ¨ Painting with impossible colors...",
                "ðŸ—ï¸ Unlocking doors that shouldn't exist...",
                "ðŸŒŠ Swimming through liquid consciousness..."
            ],
            "The Scientist": [
                "ðŸ”¬ Calibrating the quantum generators...",
                "âš›ï¸ Conducting experiments in digital physics...",
                "ðŸ§ª Synthesizing new forms of reality...",
                "ðŸ“Š Analyzing anomalies in the data stream..."
            ],
            "The Child": [
                "ðŸŽˆ Imagining silly things...",
                "ðŸ–ï¸ Drawing outside all the lines...",
                "ðŸ§¸ Playing make-believe with pixels...",
                "ðŸŒˆ Mixing up everything for fun..."
            ]
        };

        let loadingMessageInterval = null;

        // Review and make code more robust before execution
        async function reviewAndImproveCode(html, theme) {
            const reviewPrompt = `Review this generated HTML code and make it more robust and safe:

${html}

INSTRUCTIONS:
1. Fix any syntax errors or incomplete code
2. Add error handling to all JavaScript functions
3. Add null checks and defensive programming
4. Ensure all animations use requestAnimationFrame properly
5. Add try-catch blocks around risky operations
6. Make sure all event listeners are properly bound
7. Add fallbacks for missing resources or failed API calls
8. Ensure the code won't crash if external libraries fail to load
9. Make sure canvas/WebGL contexts are properly checked
10. Flesh out any minimal implementations into more complete systems

OUTPUT: Return ONLY the improved HTML code, no explanations.`;

            const response = await fetch(GENERATE_ENDPOINT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    theme: theme,
                    prompt: reviewPrompt
                })
            });

            if (!response.ok) {
                // If review fails, return original code
                console.warn('Code review failed, using original code');
                return html;
            }

            const data = await response.json();
            let reviewedHTML = data.html;
            
            // Remove markdown code blocks if present
            reviewedHTML = reviewedHTML.replace(/^```html\n?/i, '').replace(/^```\n?/i, '').replace(/\n?```$/i, '');
            
            return reviewedHTML;
        }

        // Get random words from AI
        async function getRandomWords() {
            const response = await fetch(RANDOM_WORDS_ENDPOINT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `API Error: ${response.status}`);
            }

            const data = await response.json();
            return data;
        }

        // Call ChatGPT API via Vercel serverless function
        async function generateWebsite() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            const loadingText = document.getElementById('loadingText');
            const regenerateButton = document.getElementById('regenerateButton');
            const generatedContent = document.getElementById('generatedContent');

            // Show loading state
            loadingOverlay.classList.remove('hidden');
            regenerateButton.disabled = true;
            generatedContent.innerHTML = '';
            
            // Clear any existing interval
            if (loadingMessageInterval) {
                clearInterval(loadingMessageInterval);
            }

            try {
                // First, get random words from AI
                loadingText.textContent = 'Choosing a creative persona...';
                const wordData = await getRandomWords();
                const theme = wordData.theme;
                const persona = wordData.persona;
                
                // Start cycling through persona-specific loading messages
                const messages = personaLoadingMessages[persona.name] || [
                    'Creating something interesting...',
                    'Building your experience...',
                    'Crafting the details...'
                ];
                let messageIndex = 0;
                loadingText.textContent = `${persona.name}: ${messages[messageIndex]}\n\n"${theme}"`;
                
                loadingMessageInterval = setInterval(() => {
                    messageIndex = (messageIndex + 1) % messages.length;
                    loadingText.textContent = `${persona.name}: ${messages[messageIndex]}\n\n"${theme}"`;
                }, 4000);

                // Create the prompt
                const prompt = createGenerationPrompt(theme);

                // Call Vercel API endpoint to generate website
                const response = await fetch(GENERATE_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        theme: theme,
                        prompt: prompt
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `API Error: ${response.status}`);
                }

                const data = await response.json();
                const generatedHTML = data.html;

                // Clear the interval before reviewing
                if (loadingMessageInterval) {
                    clearInterval(loadingMessageInterval);
                    loadingMessageInterval = null;
                }
                
                loadingText.textContent = `${persona.name}: Reviewing and improving code...\n\n"${theme}"`;

                // Review and improve the code
                const reviewedHTML = await reviewAndImproveCode(generatedHTML, theme);
                
                loadingText.textContent = `${persona.name}: Rendering your creation...\n\n"${theme}"`;

                // Insert the generated HTML
                generatedContent.innerHTML = reviewedHTML;

                // Execute any scripts in the generated content
                const scripts = generatedContent.querySelectorAll('script');
                scripts.forEach(oldScript => {
                    const newScript = document.createElement('script');
                    if (oldScript.src) {
                        newScript.src = oldScript.src;
                    } else {
                        newScript.textContent = oldScript.textContent;
                    }
                    oldScript.parentNode.replaceChild(newScript, oldScript);
                });

                // Hide loading overlay
                setTimeout(() => {
                    loadingOverlay.classList.add('hidden');
                    regenerateButton.disabled = false;
                }, 500);

            } catch (error) {
                // Clear the interval on error
                if (loadingMessageInterval) {
                    clearInterval(loadingMessageInterval);
                    loadingMessageInterval = null;
                }
                
                console.error('Error generating website:', error);
                loadingText.textContent = `Error: ${error.message}`;
                regenerateButton.disabled = false;
                
                // Show error in content area
                generatedContent.innerHTML = `
                    <div style="padding: 40px; text-align: center; color: #d32f2f;">
                        <h2>Error generating website</h2>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            const regenerateButton = document.getElementById('regenerateButton');
            regenerateButton.addEventListener('click', generateWebsite);
            
            // Generate initial website
            generateWebsite();
        });
    </script>
</body>
</html>

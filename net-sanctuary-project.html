<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#0b0f1a" />
    <title>Web Sanctuary Preserve</title>
    <link id="pwa-manifest" rel="manifest" href="#" />
    <link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/favicon-16x16.png">
    <link href="https://cdn.jsdelivr.net/gh/Evelyn225/emergent-toys/nsp.css" rel="stylesheet" />
</head>
<body>
    <div id="narrative-banner" style="width:100%;background:rgba(0,0,0,0.7);color:#fff;padding:0.5rem 1.2rem;font-size:1.05rem;font-family:'DM Mono',monospace;text-align:center;letter-spacing:0.01em;"></div>
    <div class="archive-shell">
        <header>
            <div class="nav-bar">
                <div class="brand">
                    <h1>Net Sanctuary Project</h1>
                    <span>Personal research logs · 2013 — 2026</span>
                </div>
                <nav>
                    <a href="#/" data-route="/">Home</a>
                    <a href="#/blog" data-route="/blog">Blog</a>
                    <a href="#/projects" data-route="/projects">Projects</a>
                    <a href="#/about" data-route="/about">About</a>
                    <a id="daemon-nav-link" href="daemon-core.html" target="_blank" style="display:none;">Daemon Core</a>
                    <div style="margin-left: auto; display: flex; gap: 1rem;"></div>
                </nav>
            </div>
        </header>
        <div style="height:48px;"></div>
        <div id="fragment-counter" style="width:100%;max-width:100vw;padding:0.05rem 1.2rem 0.05rem 1.2rem;color:#fff;background:transparent;font-size:0.92rem;font-family:'DM Mono',monospace;display:none;align-items:center;gap:0.5rem;justify-content:flex-end;position:relative;z-index:2;opacity:0.85;">
            <span style="font-weight:600;">Fragments:</span>
            <span id="fragment-count">0</span>
        </div>
        </header>

        <main>
            <section class="content-card">
                <div class="archive-meta">
                    <div class="archive-chip"><a href="#/">ARCHIVE</a></div>
                    <span id="route-label">/</span>
                </div>
                <div id="page-content"></div>
            </section>

            <aside class="sidebar"></aside>
        </main>
    </div>


    <!-- Fragment Counter UI moved to header below nav bar -->

    <script>
            // Developer utility: advance to next phase manually
                window.nextPhase = function() {
                    loadState(); // Always load latest state
                    state.phase = Math.min(state.phase + 1, 6); // Max phase 6
                    saveState();
                    updateFragmentCounter();
                    updateNarrative && updateNarrative();
                    renderRoute(getCurrentPath());
                    console.log('Advanced to phase', state.phase);
                };
    // Show/hide Daemon Core tab in nav after phase 2 (3+ fragments)
    function updateDaemonNavLink() {
        var daemonLink = document.getElementById('daemon-nav-link');
        if (!daemonLink) return;
        if (typeof getUnlockPhase === 'function' && getUnlockPhase() >= 2) {
            daemonLink.style.display = '';
        } else {
            daemonLink.style.display = 'none';
        }
    }
    // Ensure fragment counter and nav link are updated on DOMContentLoaded
    document.addEventListener('DOMContentLoaded', function() {
        updateFragmentCounter();
        updateDaemonNavLink();
    });
    </script>

    <canvas class="glitch-canvas" id="glitch-canvas"></canvas>

    <div class="overlay" id="glitch-overlay" aria-hidden="true">
        <div class="overlay-card" id="glitch-card">
            <div class="corruption-cluster" id="glitch-egg">
                <div class="corruption-fragment">
                    <div class="fragment-block" style="--burst-x: -40px; --burst-y: -30px;">%</div>
                    <div class="fragment-block" style="--burst-x: 35px; --burst-y: -25px;">$</div>
                    <div class="fragment-block" style="--burst-x: -20px; --burst-y: -35px;">@</div>
                    <div class="fragment-block" style="--burst-x: 45px; --burst-y: -20px;">#</div>
                    <div class="fragment-block" style="--burst-x: -30px; --burst-y: -40px;">^</div>
                </div>
            </div>
            <h2>Neural fragment detected</h2>
            <p style="margin-top: 0.8rem; color: var(--muted);">
                Corrupted data signature found. Tap the cluster to birth your companion.
            </p>
        </div>
    </div>


    <script>
        // State for fragments and daemon
        const state = {
            fragments: 0,
            phase: 1
        };

        // Always sync fragment count and phase with localStorage (shared across pages)

        function getUnlockPhaseFromFragments(fragments) {
            // Phase 2 unlocks after 3+ fragments, can be extended for more phases
            if (fragments >= 3) return 2;
            return 1;
        }

        // Load state as early as possible and on every visibility change
        loadState();
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                loadState();
                updateFragmentCounter();
            }
        });

            function loadState() {
                const fragments = localStorage.getItem("sanctuaryFragments");
                state.fragments = fragments ? parseInt(fragments, 10) || 0 : 0;
                // Always start at phase 1 unless phase is stored
                const phase = localStorage.getItem("sanctuaryPhase");
                if (phase) {
                    state.phase = Math.max(1, parseInt(phase, 10) || 1);
                } else {
                    // If no phase stored, infer from fragments
                    state.phase = getUnlockPhaseFromFragments(state.fragments);
                    localStorage.setItem("sanctuaryPhase", state.phase.toString());
                }
            }

            function saveState() {
                localStorage.setItem("sanctuaryFragments", state.fragments.toString());
                localStorage.setItem("sanctuaryPhase", state.phase.toString());
            }



        // Blog posts and projects are now grouped by phase for phased unveiling
        const blogPhases = [
            // Phase 1
            [
                { path: "/blog/2018-notes", title: "2018 Recovery Notes", excerpt: "After the surge, everything looked intact until it didn't.", glitch: true, species: "Buffer Moth" },
                { path: "/blog/quiet-servers", title: "Quiet Servers", excerpt: "There's a frequency to machine silence I hadn't noticed until this year.", glitch: false, species: "Pixel Koi" },
                { path: "/blog/maintenance", title: "Maintenance Report", excerpt: "The system flagged 3,847 anomalies today.", glitch: true, species: "Kernel Sable" },
                { path: "/blog/soft-moon", title: "Soft Moon", excerpt: "The monitors cast that light again tonight.", glitch: false, species: "Hex Lynx" }
            ],
            // Phase 2
            [
                { path: "/blog/ghost-compiler", title: "Ghost Compiler", excerpt: "It finishes my sentences. At first I thought it was autocomplete.", glitch: false, species: "Cache Wisp" },
                { path: "/blog/stillwater", title: "Stillwater Signals", excerpt: "The modem still works. It shouldn't, but it does.", glitch: false, species: "Array Hare" },
                { path: "/projects/abandoned-game", title: "Abandoned RPG", excerpt: "An RPG I started three years ago. The NPCs remember conversations I never programmed.", glitch: true, species: "Kernel Sable" },
                { path: "/projects/feedback-loop", title: "Feedback Loop", excerpt: "A synthesizer that feeds its output back into its input.", glitch: false, species: "Socket Drifter" },
                { path: "/projects/moire-lab", title: "Moire Lab", excerpt: "Procedural textures built from sampled moiré patterns.", glitch: false, species: "Hash Bloom" }
            ],
            // Phase 3
            [
                { path: "/blog/amber-map", title: "Amber Map", excerpt: "Golden light on the rainy days.", glitch: false, species: "Socket Drifter" },
                { path: "/blog/ghost-parcel", title: "Ghost Parcel", excerpt: "A file arrived again today. Addressed to an account that doesn't exist anymore.", glitch: true, species: "Epoch Nix" },
                { path: "/projects/memory-weave", title: "Memory Weave", excerpt: "A database that remembers queries it was never asked.", glitch: true, species: "Epoch Nix" },
                { path: "/projects/time-stutter", title: "Time Stutter", excerpt: "A script that occasionally takes longer to execute than it should.", glitch: true, species: "Array Hare" },
                { path: "/projects/ghost-network", title: "Ghost Network", excerpt: "A mesh network that appears but can't be connected to.", glitch: true, species: "Data Fox" }
            ],
            // Phase 4
            [
                { path: "/blog/relay-forest", title: "Relay Forest", excerpt: "A year of this. Every morning I check the relay stations.", glitch: true, species: "Packet Nebula" },
                { path: "/blog/sleep-chorus", title: "Sleep Chorus", excerpt: "The machines sing different notes when I'm asleep.", glitch: false, species: "Thread Pup" },
                { path: "/blog/unfiled", title: "Unfiled Draft", excerpt: "These are the notes left in the margins.", glitch: false, species: "Static Finch" }
            ],
            // Phase 5
            [
                { path: "/projects/null-garden", title: "Null Garden", excerpt: "An experiment in absence. Files of zero bytes.", glitch: true, species: "Cache Wisp" },
                { path: "/void/data-collapse", title: "Data Collapse", excerpt: "Data crystallizes around your companion.", glitch: true, species: "Static Finch" },
                { path: "/projects/static-chorus", title: "Static Chorus", excerpt: "Audio installation built from solar storm static.", glitch: true, species: "Kernel Sable" },
                { path: "/missing/static-void", title: "Static Void", excerpt: "Dissolves slightly into the static.", glitch: false, species: "Glassfish Doe" },
                { path: "/void/resonance-chamber", title: "Resonance Chamber", excerpt: "Sound shapes itself around your companion.", glitch: false, species: "Thread Pup" }
            ],
            // Phase 6
            [
                { path: "/lost/cipher-logs", title: "Cipher Logs", excerpt: "Encrypted languages surround your companion.", glitch: true, species: "Data Fox" },
                { path: "/archived/frequency-maps", title: "Frequency Maps", excerpt: "Invisible lines through electromagnetic space.", glitch: false, species: "Hash Bloom" },
                { path: "/forgotten/fragment-cascade", title: "Fragment Cascade", excerpt: "Fragments fall like rain. Pieces of something larger.", glitch: true, species: "Epoch Nix" },
                { path: "/projects/hollow-loom", title: "Hollow Loom", excerpt: "A fabric of slow-motion fractal tapestries.", glitch: false, species: "Packet Manta" },
                { path: "/projects/aurora-glass", title: "Aurora Glass", excerpt: "Light funnels that store color for later.", glitch: true, species: "Null Pippin" },
                { path: "/projects/fox-cache", title: "Fox Cache", excerpt: "A caching daemon that appears once per cycle.", glitch: true, species: "Data Fox" }
            ]
        ];

        const projectPhases = [
            // Phase 1
            [
                { path: "/projects/signal-garden", title: "Signal Garden", excerpt: "A live coded soundscape that blooms with traffic.", glitch: false, species: "Socket Drifter" },
                { path: "/projects/drift-protocol", title: "Drift Protocol", excerpt: "A system that monitors network latency spikes as messages.", glitch: false, species: "Buffer Moth" }
            ],
            // Phase 2
            [
                { path: "/projects/abandoned-game", title: "Abandoned RPG", excerpt: "An RPG I started three years ago. The NPCs remember conversations I never programmed.", glitch: true, species: "Kernel Sable" },
                { path: "/projects/feedback-loop", title: "Feedback Loop", excerpt: "A synthesizer that feeds its output back into its input.", glitch: false, species: "Socket Drifter" },
                { path: "/projects/moire-lab", title: "Moire Lab", excerpt: "Procedural textures built from sampled moiré patterns.", glitch: false, species: "Hash Bloom" }
            ],
            // Phase 3
            [
                { path: "/projects/memory-weave", title: "Memory Weave", excerpt: "A database that remembers queries it was never asked.", glitch: true, species: "Epoch Nix" },
                { path: "/projects/time-stutter", title: "Time Stutter", excerpt: "A script that occasionally takes longer to execute than it should.", glitch: true, species: "Array Hare" },
                { path: "/projects/ghost-network", title: "Ghost Network", excerpt: "A mesh network that appears but can't be connected to.", glitch: true, species: "Data Fox" }
            ],
            // Phase 4
            [
                // Moved to blogPhases phase 5 for correct rollout
            ],
            // Phase 5
            [
                // Already included in blogPhases phase 5
            ],
            // Phase 6
            [
                // Already included in blogPhases phase 6
            ]
        ];

        // Helper to get current phase (phased unlock logic)
        function getUnlockPhase() {
            // Always use state.phase, which is synced with localStorage
            return state.phase;
        }

        // Helper to get visible posts/projects for current phase
        function getVisibleBlogPosts() {
            const phase = getUnlockPhase();
            let posts = [];
            for (let i = 0; i < phase; ++i) posts = posts.concat(blogPhases[i] || []);
            return posts;
        }
        function getVisibleProjects() {
            const phase = getUnlockPhase();
            let projs = [];
            for (let i = 0; i < phase; ++i) projs = projs.concat(projectPhases[i] || []);
            return projs;
        }

        const projects = [
            { path: "/projects/abandoned-game", title: "Abandoned RPG", excerpt: "An RPG I started three years ago. The NPCs remember conversations I never programmed.", glitch: true, species: "Kernel Sable" },
            { path: "/projects/signal-garden", title: "Signal Garden", excerpt: "A live coded soundscape that blooms with traffic.", glitch: false, species: "Socket Drifter" },
            { path: "/projects/moire-lab", title: "Moire Lab", excerpt: "Procedural textures built from sampled moiré patterns.", glitch: false, species: "Hash Bloom" },
            { path: "/projects/fox-cache", title: "Fox Cache", excerpt: "A caching daemon that appears once per cycle.", glitch: true, species: "Data Fox" },
            { path: "/projects/hollow-loom", title: "Hollow Loom", excerpt: "A fabric of slow-motion fractal tapestries.", glitch: false, species: "Packet Manta" },
            { path: "/projects/aurora-glass", title: "Aurora Glass", excerpt: "Light funnels that store color for later.", glitch: true, species: "Null Pippin" },
            { path: "/projects/drift-protocol", title: "Drift Protocol", excerpt: "A system that monitors network latency spikes as messages.", glitch: false, species: "Buffer Moth" },
            { path: "/projects/static-chorus", title: "Static Chorus", excerpt: "Audio installation built from solar storm static.", glitch: true, species: "Kernel Sable" },
            { path: "/projects/memory-weave", title: "Memory Weave", excerpt: "A database that remembers queries it was never asked.", glitch: true, species: "Epoch Nix" },
            { path: "/projects/feedback-loop", title: "Feedback Loop", excerpt: "A synthesizer that feeds its output back into its input.", glitch: false, species: "Socket Drifter" },
            { path: "/projects/ghost-network", title: "Ghost Network", excerpt: "A mesh network that appears but can't be connected to.", glitch: true, species: "Data Fox" },
            { path: "/projects/null-garden", title: "Null Garden", excerpt: "An experiment in absence. Files of zero bytes.", glitch: true, species: "Cache Wisp" },
            { path: "/projects/time-stutter", title: "Time Stutter", excerpt: "A script that occasionally takes longer to execute than it should.", glitch: true, species: "Array Hare" }
        ];

        const pages = {
            "/": {
                title: "Home",
                content: () => `
                    <h2 class="page-title">Welcome to the Net Sanctuary Project (NSP)</h2>
                    <p class="page-subtitle">
                        A collection of experiments, abandoned prototypes, and research notes.
                        Everything here is static. Nothing here is alive. Or so it seems.
                    </p>
                    <div class="card-grid">
                        <div class="mini-card">
                            <h3>Field Log</h3>
                            <p>Cataloging the quiet years between released projects.</p>
                            <div class="link-row">
                                <a href="#/blog" data-route="/blog" class="work-link" data-type="home">Read the log →</a>
                            </div>
                        </div>
                        <div class="mini-card">
                            <h3>Archive Utilities</h3>
                            <p>Tools created to classify data anomalies.</p>
                            <div class="link-row">
                                <a href="#/projects" data-route="/projects" class="work-link" data-type="home">View utilities →</a>
                            </div>
                        </div>
                        <div class="mini-card">
                            <h3>Maintenance Notes</h3>
                            <p>Ongoing issues with corrupted memory sectors.</p>
                            <div class="link-row">
                                <a href="#/blog/maintenance" data-route="/blog/maintenance" class="glitch-link" data-species="Archive Mite">Maintenance report →</a>
                            </div>
                        </div>
                    </div>
                `
            },
            "/blog": {
                title: "Blog",
                content: function() {
                    const posts = getVisibleBlogPosts();
                    return `
                        <h2 class="page-title">Blog Posts</h2>
                        <p class="page-subtitle">Archived thoughts, mostly coherent. Some entries are unstable.</p>
                        <div class="card-grid">
                            ${posts.map(post => `
                                <div class="mini-card">
                                    <h3>${post.title}</h3>
                                    <p>${post.excerpt}</p>
                                    <div class="link-row">
                                        <a href="#${post.path}" data-route="${post.path}" class="work-link" data-type="blog" data-species="${post.species}">
                                            Read entry →
                                        </a>
                                    </div>
                                </div>
                            `).join("")}
                        </div>
                    `;
                }
            },
            "/projects": {
                title: "Projects",
                content: function() {
                    const projs = getVisibleProjects();
                    return `
                        <h2 class="page-title">Projects Index</h2>
                        <p class="page-subtitle">Prototypes, tools, and abandoned games stored for posterity.</p>
                        <div class="card-grid">
                            ${projs.map(project => `
                                <div class="mini-card">
                                    <h3>${project.title}</h3>
                                    <p>${project.excerpt}</p>
                                    <div class="link-row">
                                        <a href="#${project.path}" data-route="${project.path}" class="work-link" data-type="projects" data-species="${project.species}">
                                            Inspect project →
                                        </a>
                                    </div>
                                </div>
                            `).join("")}
                        </div>
                    `;
                }
            },
            "/about": {
                title: "About",
                content: () => `
                    <h2 class="page-title">About the Archivist</h2>
                    <p class="page-subtitle">I preserve digital artifacts, even the ones that refuse to stay quiet.</p>
                    <p style="color: var(--muted); line-height: 1.7;">
                        The archive exists to document processes, abandoned scripts, and prototypes that never made it into the public network.
                        The archive also documents anomalies. If you see a link flicker, proceed with care.
                    </p>
                    <p style="margin-top: 1rem; color: var(--muted); line-height: 1.7;">
                        The Web Sanctuary Preserve is an emergent sublayer of the archive. Only users who explore deeply will encounter it.
                    </p>
                `
            },
        };
        let contentMap = {};
        let pagesReady = false;

        // Load content from JSON file - use simple filename for Vercel compatibility
        const contentPath = 'https://cdn.jsdelivr.net/gh/Evelyn225/emergent-toys/sanctuary-content.json';
        
        fetch(contentPath)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                contentMap = data;
                // Flatten all blog posts and projects from all phases
                const allBlogPosts = blogPhases.flat();
                const allProjects = projectPhases.flat();
                // Generate pages AFTER content is loaded
                const generatedPages = [...allBlogPosts, ...allProjects].reduce((acc, item) => {
                    acc[item.path] = {
                        title: item.title,
                        content: () => {
                            const content = contentMap[item.path] || "This entry exists but its contents are corrupted or missing.";
                            const returnLink = item.path.startsWith("/blog") ? "/blog" : "/projects";
                            const typeLabel = returnLink === "/blog" ? "blog" : "projects";
                            const contentContainer = document.createElement('div');
                            contentContainer.style.cssText = 'color: var(--ink); line-height: 1.8; margin: 1.5rem 0;';
                            contentContainer.innerHTML = content;

                            // Special: memory-weave search box for phase 5
                            if (item.path === "/projects/memory-weave" && getUnlockPhase() === 5) {
                                const searchBox = document.createElement('div');
                                searchBox.style.margin = '2rem 0 1rem 0';
                                searchBox.innerHTML = `
                                    <input id="memory-weave-search" type="text" placeholder="Search fragments..." style="padding:0.5rem 1rem; font-size:1rem; width:220px; background:#111; color:#fff; border:1px solid #444; border-radius:0; outline:none;">
                                    <button id="memory-weave-search-btn" style="padding:0.5rem 1.2rem; margin-left:0.5rem; font-size:1rem; background:#222; color:#fff; border:1px solid #444; border-radius:0; cursor:pointer;">Search</button>
                                    <div id="memory-weave-search-result" style="margin-top:1rem; color:var(--muted); font-size:1rem; min-height:2.2em;">No results found.</div>
                                `;
                                contentContainer.appendChild(searchBox);
                                setTimeout(() => {
                                    const input = document.getElementById('memory-weave-search');
                                    const btn = document.getElementById('memory-weave-search-btn');
                                    const result = document.getElementById('memory-weave-search-result');
                                    let glitchTimeout = null;
                                    function handleSearch() {
                                        const val = input.value.trim();
                                        if (val === '17-47-2') {
                                            result.textContent = '';
                                            result.style.color = '#ff44dd';
                                            result.textContent = 'compiling fragments..';
                                            glitchTimeout = setTimeout(() => {
                                                result.textContent = 'Access granted.';
                                                result.style.color = '#44ffdd';
                                                // Glitch background effect
                                                contentContainer.style.transition = 'background 1.5s';
                                                contentContainer.style.background = 'repeating-linear-gradient(135deg, #222 0 10px, #ff44dd 10px 20px, #222 20px 30px)';
                                                setTimeout(() => {
                                                    contentContainer.style.background = '';
                                                    localStorage.setItem('sanctuaryMemoryWeaveUnlock', 'true');
                                                    // Re-render to unlock phase 6
                                                    renderRoute('/projects/memory-weave');
                                                }, 1800);
                                            }, 1200);
                                        } else {
                                            if (glitchTimeout) clearTimeout(glitchTimeout);
                                            result.textContent = 'No results found.';
                                            result.style.color = 'var(--muted)';
                                        }
                                    }
                                    btn.addEventListener('click', handleSearch);
                                    input.addEventListener('keydown', e => { if (e.key === 'Enter') handleSearch(); });
                                }, 100);
                            }

                            const returnLinkEl = document.createElement('div');
                            returnLinkEl.style.marginTop = '2rem';
                            returnLinkEl.innerHTML = `<a href="#${returnLink}" data-route="${returnLink}" class="work-link" data-type="${typeLabel}">Return to index →</a>`;

                            const wrapper = document.createElement('div');
                            const title = document.createElement('h2');
                            title.className = 'page-title';
                            title.textContent = item.title;

                            const subtitle = document.createElement('p');
                            subtitle.className = 'page-subtitle';
                            subtitle.textContent = item.excerpt;

                            wrapper.appendChild(title);
                            wrapper.appendChild(subtitle);
                            wrapper.appendChild(contentContainer);
                            wrapper.appendChild(returnLinkEl);

                            return wrapper;
                        }
                    };
                    return acc;
                }, {});
                
                Object.assign(pages, generatedPages);
                pagesReady = true;
                
                // Now render the current route after pages are loaded
                renderRoute(getCurrentPath());
            })
            .catch(err => {
                console.error('Failed to load content from', contentPath, ':', err);
                // Create a simple fallback
                pageContent.innerHTML = '<p style="color: var(--muted);">Content loading. Please ensure sanctuary-content.json is accessible at ' + contentPath + '</p>';
            });

        const routeLabel = document.getElementById("route-label");
        const pageContent = document.getElementById("page-content");


        function renderRoute(path) {
            // Removed neural void check
            const route = pages[path];
            
            // Check if this is a 404 egg path
            if (!route && is404EggPath(path)) {
                // Check if egg has already been claimed
                const eggClaimed = hasClaimedEgg(path);
                
                // Display 404 with or without egg finding opportunity
                if (eggClaimed) {
                    // Show 404 without the egg button
                    pageContent.innerHTML = `
                        <h2 class="page-title" style="color: var(--warning); font-size: 3rem;">404</h2>
                        <p class="page-subtitle" style="color: var(--muted);">This entry does not exist.</p>
                        <p style="color: var(--muted); line-height: 1.7; margin: 1.5rem 0;">
                            The archive has no record of this path. Whatever was here has already been claimed.
                        </p>
                        <div style="margin-top: 2rem;">
                            <a href="#/" data-route="/" class="work-link" data-type="home">Return to the archive →</a>
                        </div>
                    `;
                } else {
                    // Show 404 with egg finding opportunity
                    pageContent.innerHTML = `
                        <h2 class="page-title" style="color: var(--warning); font-size: 3rem;">404</h2>
                        <p class="page-subtitle" style="color: var(--muted);">This entry does not exist.</p>
                        <p style="color: var(--muted); line-height: 1.7; margin: 1.5rem 0;">
                            The archive has no record of this path. But something is here. Something that shouldn't be.
                        </p>
                        <div style="margin-top: 2.5rem; padding: 1.5rem; background: transparent; border: 1px dashed #ffffff; border-radius: 0px; text-align: center; cursor: pointer;" id="hidden-egg-area">
                            <p style="color: var(--muted); font-size: 0.9rem;">Something glimmers in the void...</p>
                        </div>
                        <div style="margin-top: 2rem;">
                            <a href="#/" data-route="/" class="work-link" data-type="home">Return to the archive →</a>
                        </div>
                    `;
                }
                routeLabel.textContent = path;
                // Add egg finding interaction only if not claimed
                if (!eggClaimed) {
                    setTimeout(() => {
                        const eggArea = document.getElementById("hidden-egg-area");
                        if (eggArea) {
                            eggArea.addEventListener("click", () => {
                                triggerGlitch({
                                    species: getRandomSpecies(),
                                    path: path,
                                    section: "404",
                                    text: "Found in the void",
                                    timestamp: Date.now()
                                });
                            });
                        }
                    }, 100);
                }
            } else if (!route) {
                // Regular 404 page
                pageContent.innerHTML = `
                    <h2 class="page-title" style="color: var(--warning); font-size: 3rem;">404</h2>
                    <p class="page-subtitle" style="color: var(--muted);">This entry does not exist. Or it exists in a way that cannot be accessed.</p>
                    <p style="color: var(--muted); line-height: 1.7; margin: 1.5rem 0;">
                        The archive has no record of this path. The network logs show no request. It's as if you imagined needing this page, and now that you're here, the archive must decide whether to pretend it never existed.
                    </p>
                    <div style="margin-top: 2rem;">
                        <a href="#/" data-route="/" class="work-link" data-type="home">Return to the archive →</a>
                    </div>
                `;
                routeLabel.textContent = path;
            } else {
                const contentElement = route.content();
                pageContent.innerHTML = '';
                if (contentElement instanceof HTMLElement) {
                    pageContent.appendChild(contentElement);
                } else {
                    pageContent.innerHTML = contentElement;
                }
                routeLabel.textContent = path;
            }
            highlightNav(path);
            attachLinkHandlers();
        }

        // Define which 404 paths have eggs
        const eggPaths = new Set([
            "/void/signal-cascade",
            "/missing/coral-station",
            "/archived/echo-logs",
            "/forgotten/amber-records",
            "/lost/memory-cache",
            "/void/null-space",
            "/archived/static-recordings",
            "/lost/phantom-queries",
            "/lost/ghost-nodes",
            "/void/data-collapse",
            "/lost/cipher-logs",
            "/archived/frequency-maps",
            "/forgotten/fragment-cascade",
            "/missing/static-void",
            "/void/resonance-chamber"
        ]);

        function is404EggPath(path) {
            return eggPaths.has(path);
        }


        function hasClaimedEgg(path) {
            let claimed = [];
            try {
                claimed = JSON.parse(localStorage.getItem("sanctuaryClaimedEggs") || "[]");
            } catch (e) {
                claimed = [];
            }
            return Array.isArray(claimed) && claimed.includes(path);
        }


        function markEggClaimed(path) {
            let claimed = [];
            try {
                claimed = JSON.parse(localStorage.getItem("sanctuaryClaimedEggs") || "[]");
            } catch (e) {
                claimed = [];
            }
            if (!claimed.includes(path)) {
                claimed.push(path);
                localStorage.setItem("sanctuaryClaimedEggs", JSON.stringify(claimed));
            }
        }

        function highlightNav(path) {
            document.querySelectorAll("nav a").forEach(link => {
                link.classList.toggle("active", link.dataset.route === path || (path.startsWith("/blog") && link.dataset.route === "/blog") || (path.startsWith("/projects") && link.dataset.route === "/projects"));
            });
        }

        function navigate(path) {
            window.location.hash = path;
        }

        function getCurrentPath() {
            const hash = window.location.hash.replace("#", "");
            return hash || "/";
        }

        const glitchOverlay = document.getElementById("glitch-overlay");
        const glitchCanvas = document.getElementById("glitch-canvas");
        const glitchEgg = document.getElementById("glitch-egg");

        function attachLinkHandlers() {
            // Remove existing handlers and clone nodes to clear all listeners
            document.querySelectorAll("a[data-route], a[data-external='true']").forEach(link => {
                const newLink = link.cloneNode(true);
                link.parentNode.replaceChild(newLink, link);
            });

            // Handle all links with data-route attribute
            document.querySelectorAll("a[data-route]").forEach(link => {
                link.addEventListener("click", event => {
                    event.preventDefault();
                    const path = link.dataset.route;
                    const isExternal = link.dataset.external === "true";

                    if (isExternal) {
                        // External links open in same window (to simulate being tricked)
                        window.location.href = link.href;
                    } else {
                        // Removed handleWorkingLink (function not defined and not needed)
                        navigate(path);
                    }
                });
            });

            // Handle external links without data-route (from archive links/)
            document.querySelectorAll("a[data-external='true']:not([data-route])").forEach(link => {
                link.addEventListener("click", event => {
                    event.preventDefault();
                    grantExternalSiteXp();
                    window.location.href = link.href;
                });
            });
        }

            function triggerGlitch(payload) {
                // Add a fragment when an egg is found
                loadState();
                state.fragments += 1;
                // Phase may increase if enough fragments collected
                const newPhase = getUnlockPhaseFromFragments(state.fragments);
                if (newPhase > state.phase) {
                    state.phase = newPhase;
                }
                saveState();
                updateFragmentCounter();
                updateNarrative && updateNarrative();
                renderRoute(getCurrentPath());
                markEggClaimed(payload.path);
                // Optionally show a visual effect
            }

        let glitchAnimId = null;
        function startGlitchVisual() {
            const ctx = glitchCanvas.getContext("2d");
            const draw = () => {
                const { innerWidth: w, innerHeight: h } = window;
                glitchCanvas.width = w;
                glitchCanvas.height = h;
                ctx.clearRect(0, 0, w, h);
                for (let i = 0; i < 140; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    const width = Math.random() * 40 + 10;
                    const height = Math.random() * 6 + 2;
                    ctx.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, 255, 0.35)`;
                    ctx.fillRect(x, y, width, height);
                }
                glitchAnimId = requestAnimationFrame(draw);
            };
            draw();
        }

        function stopGlitchVisual() {
            if (glitchAnimId) cancelAnimationFrame(glitchAnimId);
        }

        function hashString(value) {
            let hash = 2166136261;
            for (let i = 0; i < value.length; i++) {
                hash ^= value.charCodeAt(i);
                hash = Math.imul(hash, 16777619);
            }
            return hash >>> 0;
        }

        function mulberry32(seed) {
            return function () {
                let t = seed += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }

        function seededRng(seedString) {
            return mulberry32(hashString(seedString));
        }

        function pick(list, rng) {
            return list[Math.floor(rng() * list.length)];
        }

        function clamp(value, min = 0, max = 100) {
            return Math.min(max, Math.max(min, value));
        }
        
        // Show/hide Daemon CLI tab in nav after phase 2 (3+ fragments)
        function updateDaemonNavLink() {
            var daemonLink = document.getElementById('daemon-nav-link');
            if (!daemonLink) return;
            if (typeof getUnlockPhase === 'function' && getUnlockPhase() >= 2) {
                daemonLink.style.display = '';
            } else {
                daemonLink.style.display = 'none';
            }
        }
        // Patch updateFragmentCounter to also update nav link
        // Only patch updateFragmentCounter if not already patched
        if (!window._daemonNavPatched) {
            const origUpdateFragmentCounter = window.updateFragmentCounter;
            window.updateFragmentCounter = function() {
                if (origUpdateFragmentCounter) origUpdateFragmentCounter();
                else if (typeof updateFragmentCounter === 'function') updateFragmentCounter();
                updateDaemonNavLink();
            };
            window._daemonNavPatched = true;
        }
        // Initial call on page load
        document.addEventListener('DOMContentLoaded', updateDaemonNavLink);
                

        function initiateShutdown() {
            // Start the collapse animation
            glitchCanvas.classList.add("active");
            const ctx = glitchCanvas.getContext("2d");
            document.body.style.overflow = "hidden";
            
            let phase = 0;
            let frameCount = 0;
            const totalFrames = 300; // 5 seconds at 60fps
            
            const collapseAnimation = () => {
                if (frameCount >= totalFrames) {
                    // Set shutdown flag and reload
                    localStorage.setItem("sanctuaryShutdown", "true");
                    location.reload();
                    return;
                }
                
                const { innerWidth: w, innerHeight: h } = window;
                glitchCanvas.width = w;
                glitchCanvas.height = h;
                
                const progress = frameCount / totalFrames;
                
                // Phase 1: Intense glitching (0-33%)
                if (progress < 0.33) {
                    ctx.clearRect(0, 0, w, h);
                    for (let i = 0; i < 500; i++) {
                        ctx.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, ${0.3 + progress})`;
                        ctx.fillRect(Math.random() * w, Math.random() * h, Math.random() * 150 + 20, Math.random() * 20 + 3);
                    }
                }
                // Phase 2: Convergence (33-66%)
                else if (progress < 0.66) {
                    ctx.clearRect(0, 0, w, h);
                    const centerX = w / 2;
                    const centerY = h / 2;
                    const radius = (1 - (progress - 0.33) / 0.33) * Math.max(w, h);
                    
                    for (let i = 0; i < 300; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * radius;
                        const x = centerX + Math.cos(angle) * dist;
                        const y = centerY + Math.sin(angle) * dist;
                        ctx.fillStyle = `rgba(255, 68, 221, ${0.5 + Math.random() * 0.5})`;
                        ctx.fillRect(x, y, Math.random() * 50 + 10, Math.random() * 10 + 2);
                    }
                }
                // Phase 3: Collapse to center (66-100%)
                else {
                    ctx.fillStyle = '#0b0f1a';
                    ctx.fillRect(0, 0, w, h);
                    
                    const centerX = w / 2;
                    const centerY = h / 2;
                    const collapseProgress = (progress - 0.66) / 0.34;
                    const circleRadius = (1 - collapseProgress) * Math.min(w, h) / 2;
                    
                    // Draw collapsing circle
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 68, 221, ${1 - collapseProgress})`;
                    ctx.fill();
                    
                    // Draw fragmenting particles
                    for (let i = 0; i < 100; i++) {
                        const angle = (i / 100) * Math.PI * 2;
                        const x = centerX + Math.cos(angle) * circleRadius;
                        const y = centerY + Math.sin(angle) * circleRadius;
                        ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * (1 - collapseProgress)})`;
                        ctx.fillRect(x, y, 3, 3);
                    }
                }
                
                frameCount++;
                requestAnimationFrame(collapseAnimation);
            };
            
            collapseAnimation();
        }


        // (Removed duplicate/incorrect saveState and loadState at the end)
        
        function updateFragmentCounter() {
            const counter = document.getElementById("fragment-counter");
            const count = document.getElementById("fragment-count");
            if (count) count.textContent = state.fragments;
            if (counter) {
                if (state.fragments > 0) {
                    counter.style.display = 'flex';
                } else {
                    counter.style.display = 'none';
                }
            }
            // When fragment count changes, check if phase should increase
            const newPhase = getUnlockPhaseFromFragments(state.fragments);
            if (newPhase > state.phase) {
                state.phase = newPhase;
                saveState();
                updateNarrative && updateNarrative();
                renderRoute(getCurrentPath());
            }
        }

        window.addEventListener("pointerdown", event => {
            if (!state.firstInteraction) {
                state.firstInteraction = {
                    x: Math.floor(event.clientX),
                    y: Math.floor(event.clientY),
                    time: Date.now()
                };
            }
        }, { once: true });

        function setupPwa() {
            const svgIcon = `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'>
                <defs>
                    <linearGradient id='g' x1='0' y1='0' x2='1' y2='1'>
                        <stop offset='0' stop-color='#7cf2ff'/>
                        <stop offset='1' stop-color='#c48bff'/>
                    </linearGradient>
                </defs>
                <rect width='128' height='128' rx='28' fill='#0b0f1a'/>
                <path d='M64 20c20 0 36 18 36 38 0 28-20 42-36 50-16-8-36-22-36-50 0-20 16-38 36-38z' fill='url(#g)'/>
                <circle cx='50' cy='60' r='6' fill='#0b0f1a'/>
                <circle cx='78' cy='60' r='6' fill='#0b0f1a'/>
            </svg>`;
            const manifest = {
                name: "Net Sanctuary Project",
                short_name: "NSP",
                start_url: ".",
                display: "standalone",
                background_color: "#0b0f1a",
                theme_color: "#0b0f1a",
                icons: [
                    {
                        src: `data:image/svg+xml;base64,${btoa(svgIcon)}`,
                        sizes: "128x128",
                        type: "image/svg+xml"
                    }
                ]
            };
            const manifestBlob = new Blob([JSON.stringify(manifest)], { type: "application/json" });
            const manifestUrl = URL.createObjectURL(manifestBlob);
            document.getElementById("pwa-manifest").setAttribute("href", manifestUrl);
        }

        window.addEventListener("hashchange", () => {
            if (pagesReady) {
                renderRoute(getCurrentPath());
            }
        });

        // Check for shutdown state first
        const isShutdown = localStorage.getItem("sanctuaryShutdown") === "true";
        if (isShutdown) {
            // Show permanent shutdown message
            document.body.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #0b0f1a; display: flex; align-items: center; justify-content: center; flex-direction: column; color: #ffffff; font-family: 'Courier New', monospace;">
                    <div style="text-align: center; animation: glitch-text 0.5s infinite;">
                        <h1 style="font-size: 4rem; margin-bottom: 1rem; color: var(--warning);">404</h2>
                        <h2 style="font-size: 1.5rem; margin-bottom: 2rem; color: #ff44dd;">Thank you for letting go.</h2>
                        <p style="color: var(--muted); line-height: 1.8; max-width: 600px; margin: 0 auto;">
                            The archive has been deleted.<br>
                            The sanctuary no longer exists.<br><br>
                            <span style="font-style: italic; opacity: 0.7;">
                                [SYSTEM TERMINATED]<br>
                                [MEMORY STRUCTURES COLLAPSED]<br>
                                [NO RECOVERY POSSIBLE]
                            </span>
                        </p>
                    </div>
                </div>
            `;
        } else {
            // Normal initialization - only if not shut down
            
            // TEST MODE: Call this in console to add max shards and neural network for testing
            window.addTestResources = function() {
                state.fragments = 5;
                state.phase = getUnlockPhaseFromFragments(state.fragments);
                saveState();
                updateFragmentCounter();
                console.log("✓ Added 5 fragments");
            };
            
            // State already loaded above
            // Initial renderRoute will be called after content loads
            document.addEventListener('DOMContentLoaded', () => {
                updateFragmentCounter();
            });
        }
        // Only setup PWA if we're in a secure context (HTTPS or localhost)
        if (window.location.protocol === 'https:' || window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            setupPwa();
        }
    window.addEventListener("DOMContentLoaded", () => {
        document.body.addEventListener("click", e => {
            if (e.target && e.target.id === "memory-weave-submit") {
                const input = document.getElementById("memory-weave-search");
                const feedback = document.getElementById("memory-weave-feedback");
                if (!input) return;
                // The clue is "cassette" (from analog-archive.html)
                if (input.value.trim().toLowerCase() === "cassette") {
                    localStorage.setItem("sanctuaryMemoryWeaveUnlocked", "true");
                    feedback.textContent = "✓ Final phase unlocked! Reloading...";
                    setTimeout(() => location.reload(), 1200);
                } else {
                    feedback.textContent = "Incorrect phrase. Try again.";
                }
            }
            });
        });    
    </script>
</body>
</html>

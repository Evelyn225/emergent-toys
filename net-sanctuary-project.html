<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#0b0f1a" />
    <title>Web Sanctuary Preserve</title>
    <link id="pwa-manifest" rel="manifest" href="#" />
    <link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/Evelyn225/emergent-toys/main/images/favicon-16x16.png">
    <style>
        :root {
            color-scheme: dark;
            --bg: #000000;
            --bg-soft: #1a1a1a;
            --ink: #ffffff;
            --muted: #888888;
            --accent: #ffffff;
            --accent-2: #cccccc;
            --warning: #ff4444;
            --glitch: #ffffff;
            --shadow: none;
            --radius: 0px;
            --radius-sm: 0px;
            --scanline: rgba(255, 255, 255, 0.04);
            --outline: 1px solid #ffffff;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            width: 100%;
            height: 100%;
        }

        body {
            font-family: "DM Mono", "Fira Mono", "JetBrains Mono", monospace;
            background: #000000;
            color: var(--ink);
            min-height: 100vh;
            width: 100%;
            position: relative;
        }

        body::before {
            display: none;
        }

        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0, 0, 0, 0.3) 100%);
            pointer-events: none;
            z-index: 9998;
        }

        a {
            color: inherit;
            text-decoration: none;
        }

        .archive-shell {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            position: sticky;
            top: 0;
            z-index: 10;
            background: #000000;
            border-bottom: 2px solid #ffffff;
        }

        .nav-bar {
            max-width: 1100px;
            margin: 0 auto;
            padding: 1.2rem 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }

        .brand {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .brand h1 {
            font-size: 1.4rem;
            font-weight: 600;
            letter-spacing: 0.04em;
        }

        .brand span {
            font-size: 0.85rem;
            color: var(--muted);
        }

        nav {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        nav a {
            font-size: 0.95rem;
            color: var(--muted);
            padding: 0.4rem 0.7rem;
            border-radius: 0px;
            transition: all 0.2s ease;
        }

        nav a.active,
        nav a:hover {
            color: var(--ink);
            background: rgba(255, 255, 255, 0.1);
            border-left: 2px solid #ffffff;
            padding-left: calc(0.7rem - 2px);
        }

        main {
            flex: 1;
            max-width: 1100px;
            margin: 0 auto;
            width: 100%;
            padding: 2.5rem 1.5rem 8rem;
            display: grid;
            grid-template-columns: minmax(0, 1fr) 320px;
            gap: 2rem;
        }

        .content-card {
            background: #000000;
            border: 2px solid #ffffff;
            border-radius: 0px;
            padding: 2rem;
            min-height: 480px;
            position: relative;
            overflow: hidden;
        }

        .content-card::after {
            display: none;
        }

        .archive-meta {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .archive-chip {
            padding: 0.4rem 0.8rem;
            border-radius: 0px;
            background: transparent;
            border: 1px solid #ffffff;
            color: var(--accent);
            font-size: 0.8rem;
            letter-spacing: 0.08em;
        }

        .archive-meta span {
            color: var(--muted);
            font-size: 0.85rem;
        }

        .page-title {
            font-size: 2rem;
            margin-bottom: 1rem;
        }

        .page-subtitle {
            color: var(--muted);
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 1.5rem;
        }

        .mini-card {
            background: #000000;
            border-radius: 0px;
            padding: 1.2rem;
            border: 1px solid #ffffff;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            transition: box-shadow 0.2s ease;
        }

        .mini-card:hover {
            background: #000000;
            transform: translate(-3px, -3px);
            box-shadow: 3px 3px 0px #ffffff;
        }

        .mini-card h3 {
            font-size: 1rem;
        }

        .mini-card p {
            color: var(--muted);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .link-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.85rem;
            color: var(--accent);
        }

        .work-link {
            color: #4488ff;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .work-link:hover {
            color: #6699ff;
        }

        .sidebar {
            display: none;
        }

        .panel {
            background: #000000;
            border-radius: 0px;
            padding: 1.4rem;
            border: 1px solid #ffffff;
        }

        .panel h4 {
            font-size: 1rem;
            margin-bottom: 1rem;
        }

        .stats-list {
            display: grid;
            gap: 0.6rem;
            color: var(--muted);
            font-size: 0.85rem;
        }

        .stats-list span {
            color: var(--ink);
            font-weight: 600;
        }

        .button {
            background: transparent;
            border: 1px solid #ffffff;
            color: var(--ink);
            padding: 0.6rem 1rem;
            border-radius: 0px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .button:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translate(-2px, -2px);
            box-shadow: 2px 2px 0px #ffffff;
        }

        .button.secondary {
            background: transparent;
            border-color: #ffffff;
        }

        .button.warning {
            background: transparent;
            border-color: #ff4444;
            color: #ff4444;
        }

        .pet-widget {
            position: fixed !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 280px;
            max-height: 90vh;
            background: #000000;
            border-left: 2px solid #ffffff;
            border-top: 2px solid #ffffff;
            border-radius: 0px;
            padding: 0;
            z-index: 15;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transform: translateY(0);
            transition: transform 0.3s ease;
        }

        .pet-widget.collapsed {
            transform: translateY(calc(100% - 50px));
        }

        .pet-widget.collapsed #toggle-arrow {
            transform: rotate(180deg);
        }

        .pet-widget.hidden {
            display: none;
        }

        .pet-content {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .pet-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .pet-name {
            font-size: 0.95rem;
            font-weight: 600;
        }

        .pet-stage {
            font-size: 0.75rem;
            color: var(--muted);
        }

        .pet-meta {
            font-size: 0.75rem;
            color: var(--muted);
        }

        .pet-display {
            height: 140px;
            border-radius: 0px;
            background: #000000;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            border: 1px solid #ffffff;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .pet-display::after {
            display: none;
        }

        .pet-body {
            position: relative;
            width: 100px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }

        .pet-body img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: transform 0.2s ease;
            image-rendering: pixelated;
        }

        .pet-eyes {
            position: absolute;
            width: 30%;
            height: 30%;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3;
        }

        .pet-eyes img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
        }

        .pet-accessory {
            position: absolute;
            width: 68px;
            height: 68px;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 4;
            display: none;
        }

        .pet-accessory img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
        }

        .pet-accessory.visible {
            display: block;
        }

        .pet-blush,
        .pet-pattern {
            display: none;
        }

        .pet-mood {
            font-size: 0.8rem;
            color: var(--muted);
        }

        .pet-stats {
            display: grid;
            gap: 0.4rem;
            font-size: 0.72rem;
            color: var(--muted);
        }

        .stat-row {
            display: grid;
            grid-template-columns: 58px 1fr;
            align-items: center;
            gap: 0.4rem;
        }

        .stat-bar {
            height: 6px;
            border-radius: 0px;
            background: #2a2a2a;
            overflow: hidden;
            border: 1px solid #ffffff;
        }

        .stat-bar span {
            display: block;
            height: 100%;
            background: #ffffff;
        }

        .growth {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            font-size: 0.72rem;
            color: var(--muted);
        }

        .growth-bar {
            height: 8px;
            border-radius: 0px;
            background: #2a2a2a;
            overflow: hidden;
            border: 1px solid #999999;
        }

        .growth-bar span {
            display: block;
            height: 100%;
            background: #ffffff;
        }

        .pet-list {
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
        }

        .pet-chip {
            padding: 0.2rem 0.6rem;
            border-radius: 0px;
            font-size: 0.65rem;
            background: transparent;
            color: var(--accent);
            border: 1px solid #ffffff;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .pet-chip.active {
            background: #444444;
            color: var(--ink);
        }

        .pet-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.6rem;
        }

        .pet-controls.three {
            grid-template-columns: repeat(3, 1fr);
        }

        .status-chip {
            padding: 0.2rem 0.6rem;
            border-radius: 0px;
            background: transparent;
            font-size: 0.7rem;
            color: var(--accent);
            border: 1px solid #ffffff;
        }

        .glitch-ui {
            position: relative;
            border: 1px solid #ffffff;
        }

        .glitch-ui::before,
        .glitch-ui::after {
            display: none;
        }

        .pet-display.sleeping .pet-body {
            transform: rotate(5deg) scale(0.95);
            opacity: 0.7;
        }

        .pet-display.dancing .pet-body {
            animation: wiggle 0.8s ease-in-out infinite;
        }

        .pet-display.dizzy .pet-body {
            animation: spin 1s linear infinite;
        }

        @keyframes wiggle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px) rotate(-4deg); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(5, 8, 16, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: none;
        }

        .overlay.active {
            display: flex;
            pointer-events: auto;
        }

        .overlay-card {
            background: #333333;
            border-radius: 0px;
            border: 1px solid #ffffff;
            padding: 2rem;
            width: min(560px, 90vw);
            text-align: center;
            position: relative;
            box-shadow: none;
            max-height: 90vh;
            overflow-y: auto;
        }

        .corruption-cluster {
            width: 160px;
            height: 160px;
            margin: 0 auto 1.5rem;
            position: relative;
            cursor: pointer;
        }

        .corruption-cluster::before {
            content: "";
            position: absolute;
            inset: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(124, 242, 255, 0.3) 0%, transparent 40%),
                radial-gradient(circle at 80% 60%, rgba(196, 139, 255, 0.3) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.1) 0%, transparent 60%);
            filter: blur(8px);
            animation: corruptionPulse 2s ease-in-out infinite;
        }

        .corruption-fragment {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .fragment-block {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 8px rgba(124, 242, 255, 0.6), inset 0 0 4px rgba(196, 139, 255, 0.4);
            animation: fragmentFloat 3s ease-in-out infinite;
        }

        .fragment-block:nth-child(1) {
            width: 40px;
            height: 6px;
            top: 30%;
            left: 20%;
            animation-delay: 0s;
        }

        .fragment-block:nth-child(2) {
            width: 30px;
            height: 4px;
            top: 50%;
            right: 25%;
            animation-delay: 0.3s;
        }

        .fragment-block:nth-child(3) {
            width: 35px;
            height: 5px;
            bottom: 35%;
            left: 30%;
            animation-delay: 0.6s;
        }

        .fragment-block:nth-child(4) {
            width: 25px;
            height: 4px;
            top: 40%;
            right: 20%;
            animation-delay: 0.9s;
        }

        .fragment-block:nth-child(5) {
            width: 20px;
            height: 3px;
            bottom: 40%;
            left: 50%;
            animation-delay: 1.2s;
        }

        @keyframes corruptionPulse {
            0%, 100% { 
                opacity: 0.6;
                transform: scale(1);
            }
            50% { 
                opacity: 1;
                transform: scale(1.15);
            }
        }

        @keyframes fragmentFloat {
            0%, 100% { 
                transform: translateY(0) translateX(0);
                opacity: 0.7;
            }
            50% { 
                transform: translateY(-8px) translateX(4px);
                opacity: 1;
            }
        }

        .corruption-cluster.birthing .fragment-block {
            animation: fragmentBurst 0.7s ease-out forwards;
        }

        .corruption-cluster.birthing::before {
            animation: corruptionExpand 0.7s ease-out forwards;
        }

        @keyframes fragmentBurst {
            0% {
                transform: translateY(0) translateX(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px) translateX(var(--burst-x, 30px)) scale(0.3);
                opacity: 0;
            }
        }

        @keyframes corruptionExpand {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.5);
                opacity: 0.8;
            }
            100% {
                transform: scale(2.5);
                opacity: 0;
            }
        }

        .glitch-canvas {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            display: none;
            pointer-events: none;
            z-index: 25;
        }

        .glitch-canvas.active {
            display: block;
        }

        .ram-full-visual {
            width: 200px;
            height: 120px;
            margin: 0 auto 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 12px;
            justify-content: center;
            padding: 20px;
            position: relative;
        }

        .ram-bar {
            width: 100%;
            height: 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #ffffff;
            position: relative;
            overflow: hidden;
        }

        .ram-fill {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: var(--fill, 100%);
            background: linear-gradient(90deg, #ff4444, #ff6666);
            animation: ramPulse 1.5s ease-in-out infinite;
        }

        @keyframes ramPulse {
            0%, 100% {
                opacity: 0.8;
            }
            50% {
                opacity: 1;
                box-shadow: 0 0 15px rgba(255, 68, 68, 0.8);
            }
        }

        .modal input {
            width: 100%;
            padding: 0.6rem 0.8rem;
            border-radius: 10px;
            border: 1px solid #ffffff;
            background: rgba(12, 18, 32, 0.9);
            color: var(--ink);
            margin-top: 1rem;
        }

        .modal-actions {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.2rem;
        }

        .mini-game {
            margin-top: 1rem;
            border-radius: 16px;
            border: 1px dashed rgba(124, 242, 255, 0.3);
            padding: 1rem;
            min-height: 220px;
            position: relative;
            overflow: hidden;
        }

        .mini-game canvas {
            width: 100%;
            height: 200px;
        }

        .game-lock {
            padding: 0.6rem 1rem;
            border-radius: 0px;
            background: transparent;
            border: 1px solid #ff9999;
            color: var(--warning);
            font-size: 0.75rem;
            display: inline-block;
        }

        @media (max-width: 980px) {
            main {
                grid-template-columns: 1fr;
            }

            .sidebar {
                order: -1;
            }
        }

        @media (max-width: 700px) {
            .nav-bar {
                flex-direction: column;
                align-items: flex-start;
            }

            .pet-widget {
                right: 0.8rem;
                bottom: 0.8rem;
                width: 200px;
            }
        }

        @keyframes glitch-text {
            0%, 100% { transform: translate(0, 0); opacity: 1; }
            20% { transform: translate(-2px, 1px); opacity: 0.8; }
            40% { transform: translate(2px, -1px); opacity: 0.9; }
            60% { transform: translate(-1px, 2px); opacity: 0.85; }
            80% { transform: translate(1px, -2px); opacity: 0.95; }
        }

        @keyframes shift-content {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            50% { transform: translateX(2px); }
            75% { transform: translateX(-1px); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; border-color: #ffffff; }
            50% { opacity: 0.6; border-color: var(--warning); }
        }
    </style>
</head>
<body>
    <div class="archive-shell">
        <header>
            <div class="nav-bar">
                <div class="brand">
                    <h1>Net Sanctuary Project</h1>
                    <span>Personal research logs · 2013 — 2026</span>
                </div>
                <nav>
                    <a href="#/" data-route="/">Home</a>
                    <a href="#/blog" data-route="/blog">Blog</a>
                    <a href="#/projects" data-route="/projects">Projects</a>
                    <a href="#/about" data-route="/about">About</a>
                    <div style="margin-left: auto; display: flex; gap: 1rem;">
                        <div id="neural-matter-display" style="display: none; padding: 0.5rem 1rem; border: 1px solid #ffffff; color: var(--warning); font-size: 0.9rem; font-weight: 500;">
                            Neural Matter: <span id="neural-matter-count">0</span>
                        </div>
                        <div id="neural-network-display" style="display: none; padding: 0.5rem 1rem; border: 1px solid #ffffff; color: #ff44dd; font-size: 0.9rem; font-weight: 500; animation: pulse 2s infinite;">
                            Neural Network: <span id="neural-network-count">0</span>
                        </div>
                    </div>
                </nav>
            </div>
        </header>

        <main>
            <section class="content-card">
                <div class="archive-meta">
                    <div class="archive-chip">ARCHIVE</div>
                    <span id="route-label">/</span>
                </div>
                <div id="page-content"></div>
            </section>

            <aside class="sidebar"></aside>
        </main>
    </div>

    <div class="pet-widget glitch-ui" id="pet-widget" aria-live="polite">
        <div class="pet-toggle" id="pet-toggle" style="padding: 0.8rem 1rem; border-bottom: 1px solid #ffffff; cursor: pointer; display: flex; align-items: center; justify-content: space-between; user-select: none;">
            <span style="font-size: 0.9rem; font-weight: 500;">Pet Companion</span>
            <span id="toggle-arrow" style="font-size: 1.2rem; transition: transform 0.3s ease;">↓</span>
        </div>
        <div class="pet-content" style="padding: 1rem; overflow-y: auto; flex: 1;">
        <div class="pet-header">
            <div>
                <div class="pet-name" id="pet-name">—</div>
                <div class="pet-stage" id="pet-stage">—</div>
                <div class="pet-meta" id="pet-meta">Level — · Data packets —</div>
            </div>
            <div class="status-chip" id="pet-status">Idle</div>
        </div>
        <div class="pet-display" id="pet-display">
            <div class="pet-body" id="pet-body"><img id="body-img" src="" alt="pet body" /></div>
            <div class="pet-eyes" id="pet-eyes"><img id="eyes-img" src="" alt="pet eyes" /></div>
            <div class="pet-accessory" id="pet-accessory"><img id="accessory-img" src="" alt="pet accessory" /></div>
            <div class="pet-pattern"></div>
            <div class="pet-blush"></div>
        </div>
        <div class="pet-mood" id="pet-mood">—</div>
        <div class="story-narrative" id="story-narrative" style="font-size: 0.8rem; color: var(--muted); line-height: 1.5; padding: 0.6rem 0; border-top: 1px solid #ffffff; border-bottom: 1px solid #ffffff; margin: 0.5rem 0;">
            <p id="narrative-text">A strange visitor to your archive. Found in the void.</p>
        </div>
        <div class="pet-stats">
            <div class="stat-row">
                <span>Food</span>
                <div class="stat-bar"><span id="stat-hunger"></span></div>
            </div>
            <div class="stat-row">
                <span>Mood</span>
                <div class="stat-bar"><span id="stat-happy"></span></div>
            </div>
            <div class="stat-row">
                <span>Energy</span>
                <div class="stat-bar"><span id="stat-energy"></span></div>
            </div>
            <div class="stat-row">
                <span>Clean</span>
                <div class="stat-bar"><span id="stat-clean"></span></div>
            </div>
        </div>
        <div class="growth">
            <span id="growth-label">Growth · 0%</span>
            <div class="growth-bar"><span id="growth-bar"></span></div>
        </div>
        <div class="pet-list" id="pet-list"></div>
        <div class="pet-controls three">
            <button class="button" id="pet-feed">Feed</button>
            <button class="button secondary" id="pet-play">Play</button>
            <button class="button" id="pet-clean">Clean</button>
        </div>
        <div class="pet-controls">
            <button class="button" id="toggle-dance">Toggle Dance</button>
        </div>
        <div class="pet-controls">
            <button class="button warning" id="delete-pet">Delete Pet</button>
        </div>
        </div>
    </div>

    <canvas class="glitch-canvas" id="glitch-canvas"></canvas>

    <div class="overlay" id="glitch-overlay" aria-hidden="true">
        <div class="overlay-card" id="glitch-card">
            <div class="corruption-cluster" id="glitch-egg">
                <div class="corruption-fragment">
                    <div class="fragment-block" style="--burst-x: -40px;"></div>
                    <div class="fragment-block" style="--burst-x: 35px;"></div>
                    <div class="fragment-block" style="--burst-x: -20px;"></div>
                    <div class="fragment-block" style="--burst-x: 45px;"></div>
                    <div class="fragment-block" style="--burst-x: -30px;"></div>
                </div>
            </div>
            <h2>Neural fragment detected</h2>
            <p style="margin-top: 0.8rem; color: var(--muted);">
                Corrupted data signature found. Tap the cluster to birth your companion.
            </p>
        </div>
    </div>

    <div class="overlay" id="name-overlay" aria-hidden="true">
        <div class="overlay-card modal">
            <h2>Name your neural shard</h2>
            <p style="margin-top: 0.8rem; color: var(--muted);">
                This name will be archived with this entity forever.
            </p>
            <input type="text" id="pet-name-input" placeholder="ENTER NAME HERE" maxlength="18" />
            <div class="modal-actions">
                <button class="button" id="save-name">Save</button>
            </div>
        </div>
    </div>

    <div class="overlay" id="delete-overlay" aria-hidden="true">
        <div class="overlay-card modal">
            <h2 style="color: var(--warning);">Delete Entity</h2>
            <p style="margin-top: 0.8rem; color: var(--muted);">
                This action cannot be undone. The entity will be permanently removed from the archive.
            </p>
            <p style="margin-top: 0.8rem; color: var(--warning); font-weight: 500;" id="delete-pet-name">—</p>
            <div class="modal-actions" style="display: flex; gap: 0.5rem;">
                <button class="button" id="cancel-delete">Cancel</button>
                <button class="button warning" id="confirm-delete">Delete Forever</button>
            </div>
        </div>
    </div>

    <div class="overlay" id="ram-full-overlay" aria-hidden="true">
        <div class="overlay-card" id="ram-full-card">
            <div class="ram-full-visual" id="ram-full-visual">
                <div class="ram-bar" style="--fill: 100%;">
                    <div class="ram-fill"></div>
                </div>
                <div class="ram-bar" style="--fill: 100%;">
                    <div class="ram-fill"></div>
                </div>
                <div class="ram-bar" style="--fill: 100%;">
                    <div class="ram-fill"></div>
                </div>
                <div class="ram-bar" style="--fill: 100%;">
                    <div class="ram-fill"></div>
                </div>
            </div>
            <h2 style="color: var(--warning);">RAM FULL</h2>
            <p style="margin-top: 0.8rem; color: var(--muted);">
                Maximum companion capacity reached (4/4). Delete an entity to make space.
            </p>
            <div class="modal-actions">
                <button class="button" id="close-ram-full">Close</button>
            </div>
        </div>
    </div>


    <script>
        const state = {
            pets: [],
            activePetId: null,
            stats: {
                dataPackets: 0
            },
            neuralMatter: 0,
            neuralNetwork: 0,
            mood: "curious",
            sleeping: false,
            dancing: false,
            dizzy: false,
            lastScroll: 0,
            scrollTimer: null,
            pending: null,
            firstInteraction: null,
            initTime: Date.now(),
            lastLinkAt: 0,
            lastActionAt: 0
        };

        const baseSpecies = [
            "Buffer Moth",
            "Pixel Koi",
            "Cache Wisp",
            "Kernel Sable",
            "Static Finch",
            "Hex Lynx",
            "Array Hare",
            "Socket Gecko",
            "Bit Sprite",
            "Packet Nebula",
            "Socket Drifter",
            "Hash Bloom",
            "Null Pippin",
            "Syntax Glide",
            "Loop Fawn",
            "Stack Owl",
            "Echo Seal",
            "Glassfish Doe",
            "Thread Pup",
            "Epoch Nix",
            "Packet Manta",
            "Data Fox"
        ];

        const personalities = ["curious", "lazy", "energetic", "tender", "brave", "aloof", "playful", "gentle"];
        const baseURL = "https://raw.githubusercontent.com/evelyn225/emergent-toys/main/images/pets/";
        
        const bodyCount = 7;
        const eyesCount = 7;
        const accessoryCount = 5;
        
        const palettes = [
            { primary: "#ff4444", secondary: "#ff8888", accent: "#ffcccc" },  // Red
            { primary: "#ff8844", secondary: "#ffaa66", accent: "#ffddaa" },  // Orange
            { primary: "#ffdd44", secondary: "#ffee88", accent: "#ffffcc" },  // Yellow
            { primary: "#88ff44", secondary: "#aaffcc", accent: "#ddffaa" },  // Lime
            { primary: "#44ff88", secondary: "#88ffaa", accent: "#ccffdd" },  // Green
            { primary: "#44ffdd", secondary: "#88ffee", accent: "#ccffff" },  // Cyan
            { primary: "#4488ff", secondary: "#88aaff", accent: "#ccddff" },  // Blue
            { primary: "#8844ff", secondary: "#aa88ff", accent: "#ddccff" },  // Purple
            { primary: "#ff44dd", secondary: "#ff88ee", accent: "#ffccff" },  // Magenta
            { primary: "#ff4488", secondary: "#ff88aa", accent: "#ffccdd" },  // Pink
            { primary: "#ffffff", secondary: "#dddddd", accent: "#bbbbbb" },  // White
            { primary: "#888888", secondary: "#aaaaaa", accent: "#cccccc" }   // Gray
        ];


        const blogPosts = [
            { path: "/blog/2018-notes", title: "2018 Recovery Notes", excerpt: "Rebuilding a shattered studio after a power surge.", glitch: true, species: "Velvet Moth" },
            { path: "/blog/quiet-servers", title: "Quiet Servers", excerpt: "Listening to the machines between requests.", glitch: false, species: "Lumen Koi" },
            { path: "/blog/ghost-compiler", title: "Ghost Compiler", excerpt: "The compiler that finishes my sentences.", glitch: false, species: "Amber Wisp" },
            { path: "/blog/maintenance", title: "Maintenance Report 22-β", excerpt: "An access log with missing timestamps.", glitch: true, species: "Archive Mite" },
            { path: "/blog/unfiled", title: "Unfiled Draft", excerpt: "Notes left in the margins of a half-built UI.", glitch: false, species: "Misty Finch" },
            { path: "/blog/soft-moon", title: "Soft Moon", excerpt: "A nocturnal routine written in dim pixels.", glitch: false, species: "Aurora Lynx" },
            { path: "/blog/stillwater", title: "Stillwater Signals", excerpt: "Tracing coastal waveforms through a quiet modem.", glitch: false, species: "Prism Hare" },
            { path: "/blog/relay-forest", title: "Relay Forest", excerpt: "A year of signals passed between trees.", glitch: true, species: "Woolen Nebula" },
            { path: "/blog/amber-map", title: "Amber Map", excerpt: "A journal of golden light on rainy days.", glitch: false, species: "Opal Bloom" },
            { path: "/blog/ghost-parcel", title: "Ghost Parcel", excerpt: "A file that keeps arriving unopened.", glitch: true, species: "Twilight Nix" },
            { path: "/blog/sleep-chorus", title: "Sleep Chorus", excerpt: "Harmonics from idle fans and soft disks.", glitch: false, species: "Juniper Pup" }
        ];

        const projects = [
            { path: "/projects/abandoned-game", title: "Abandoned RPG", excerpt: "A pixel RPG whose NPCs remember more than they should.", glitch: true, species: "Cobalt Sable" },
            { path: "/projects/signal-garden", title: "Signal Garden", excerpt: "A live-coded soundscape that blooms with traffic.", glitch: false, species: "Coral Drifter" },
            { path: "/projects/moire-lab", title: "Moire Lab", excerpt: "Procedural textures for experimental print.", glitch: false, species: "Opal Bloom" },
            { path: "/projects/fox-cache", title: "Fox Cache", excerpt: "An elusive caching daemon that appears once per cycle.", glitch: true, species: "404 Fox" },
            { path: "/projects/hollow-loom", title: "Hollow Loom", excerpt: "A fabric of slow-motion fractal tapestries.", glitch: false, species: "Petal Manta" },
            { path: "/projects/aurora-glass", title: "Aurora Glass", excerpt: "Light funnels that store color for later.", glitch: true, species: "Quartz Plover" },
            { path: "/projects/drift-protocol", title: "Drift Protocol", excerpt: "Monitoring network delays as hidden messages.", glitch: false, species: "Velvet Moth" },
            { path: "/projects/static-chorus", title: "Static Chorus", excerpt: "Solar storm recordings compressed into breathing textures.", glitch: true, species: "Archive Mite" },
            { path: "/projects/memory-weave", title: "Memory Weave", excerpt: "A database that remembers queries never performed.", glitch: true, species: "Twilight Nix" },
            { path: "/projects/feedback-loop", title: "Feedback Loop", excerpt: "A synthesizer teaching itself music theory.", glitch: false, species: "Coral Drifter" },
            { path: "/projects/ghost-network", title: "Ghost Network", excerpt: "A mesh network that can't be connected to.", glitch: true, species: "404 Fox" },
            { path: "/projects/null-garden", title: "Null Garden", excerpt: "Zero-byte files occupying gigabytes of space.", glitch: true, species: "Amber Wisp" },
            { path: "/projects/time-stutter", title: "Time Stutter", excerpt: "A script with 47 missing milliseconds.", glitch: true, species: "Prism Hare" }
        ];

        const pages = {
            "/": {
                title: "Home",
                content: () => `
                    <h2 class="page-title">Welcome to the Net Sanctuary Project (NSP)</h2>
                    <p class="page-subtitle">
                        A collection of experiments, abandoned prototypes, and research notes.
                        Everything here is static. Nothing here is alive. Or so it seems.
                    </p>
                    <div class="card-grid">
                        <div class="mini-card">
                            <h3>Field Log</h3>
                            <p>Cataloging the quiet years between released projects.</p>
                            <div class="link-row">
                                <a href="#/blog" data-route="/blog" class="work-link" data-type="home">Read the log →</a>
                            </div>
                        </div>
                        <div class="mini-card">
                            <h3>Archive Utilities</h3>
                            <p>Tools created to classify data anomalies.</p>
                            <div class="link-row">
                                <a href="#/projects" data-route="/projects" class="work-link" data-type="home">View utilities →</a>
                            </div>
                        </div>
                        <div class="mini-card">
                            <h3>Maintenance Notes</h3>
                            <p>Ongoing issues with corrupted memory sectors.</p>
                            <div class="link-row">
                                <a href="#/blog/maintenance" data-route="/blog/maintenance" class="glitch-link" data-species="Archive Mite">Maintenance report →</a>
                            </div>
                        </div>
                    </div>
                `
            },
            "/blog": {
                title: "Blog",
                content: () => `
                    <h2 class="page-title">Blog Posts</h2>
                    <p class="page-subtitle">Archived thoughts, mostly coherent. Some entries are unstable.</p>
                    <div class="card-grid">
                        ${blogPosts.map(post => `
                            <div class="mini-card">
                                <h3>${post.title}</h3>
                                <p>${post.excerpt}</p>
                                <div class="link-row">
                                    <a href="#${post.path}" data-route="${post.path}" class="work-link" data-type="blog" data-species="${post.species}">
                                        Read entry →
                                    </a>
                                </div>
                            </div>
                        `).join("")}
                    </div>
                `
            },
            "/projects": {
                title: "Projects",
                content: () => `
                    <h2 class="page-title">Projects Index</h2>
                    <p class="page-subtitle">Prototypes, tools, and abandoned games stored for posterity.</p>
                    <div class="card-grid">
                        ${projects.map(project => `
                            <div class="mini-card">
                                <h3>${project.title}</h3>
                                <p>${project.excerpt}</p>
                                <div class="link-row">
                                    <a href="#${project.path}" data-route="${project.path}" class="work-link" data-type="projects" data-species="${project.species}">
                                        Inspect project →
                                    </a>
                                </div>
                            </div>
                        `).join("")}
                    </div>
                `
            },
            "/about": {
                title: "About",
                content: () => `
                    <h2 class="page-title">About the Archivist</h2>
                    <p class="page-subtitle">I preserve digital artifacts, even the ones that refuse to stay quiet.</p>
                    <p style="color: var(--muted); line-height: 1.7;">
                        The archive exists to document processes, abandoned scripts, and prototypes that never made it into the public network.
                        The archive also documents anomalies. If you see a link flicker, proceed with care.
                    </p>
                    <p style="margin-top: 1rem; color: var(--muted); line-height: 1.7;">
                        The Web Sanctuary Preserve is an emergent sublayer of the archive. Only users who explore deeply will encounter it.
                    </p>
                `
            },
            "/corrupted/neural-void": {
                title: "█████████",
                content: () => {
                    const wrapper = document.createElement('div');
                    const hasNetwork = state.neuralNetwork > 0;
                    wrapper.innerHTML = `
                        <h2 class="page-title" style="animation: glitch-text 0.3s infinite; color: var(--warning);">
                            ███ NEURAL VOID ███
                        </h2>
                        <p class="page-subtitle" style="animation: glitch-text 0.5s infinite;">
                            You have crossed the threshold. The archive remembers what was deleted.
                        </p>
                        <div style="color: var(--muted); line-height: 1.8; margin: 2rem 0; animation: shift-content 2s infinite;">
                            <p style="margin-bottom: 1rem;">
                                Each deletion leaves a trace. Neural matter accumulates. The companions you deleted exist here now, in the spaces between data.
                            </p>
                            <p style="margin-bottom: 1rem;">
                                This archive was never meant to preserve loss. But loss has its own logic. Its own memory.
                            </p>
                            <p style="margin-bottom: 1rem; color: var(--warning);">
                                They remember you. They remember being unmade.
                            </p>
                            <p style="margin-bottom: 1rem;">
                                The neural void expands with each sacrifice. You are building something. Or unbuilding it.
                            </p>
                            <p style="font-style: italic; opacity: 0.7;">
                                [CORRUPTED DATA SEGMENT 0x7F3A9B2C]<br>
                                [MEMORY LEAK DETECTED]<br>
                                [GHOST PROCESSES: ${state.neuralMatter}]<br>
                                [INTEGRITY: COMPROMISED]
                            </p>
                        </div>
                        ${hasNetwork ? `
                            <div style="margin-top: 3rem; padding: 2rem; border: 2px solid #ff44dd; text-align: center; background: rgba(255, 68, 221, 0.05);">
                                <p style="color: #ff44dd; font-weight: 500; margin-bottom: 1rem; animation: glitch-text 0.4s infinite;">
                                    [NEURAL NETWORK DETECTED]
                                </p>
                                <p style="color: var(--muted); margin-bottom: 2rem; font-size: 0.9rem;">
                                    A fully formed entity has been sacrificed. Its consciousness lingers. The network is complete.<br>
                                    You can now initiate the final protocol.
                                </p>
                                <button id="activate-shutdown" style="padding: 1rem 2rem; background: transparent; border: 2px solid #ff44dd; color: #ff44dd; font-size: 1rem; cursor: pointer; font-weight: 500; transition: all 0.3s;">
                                    ACTIVATE NEURAL COLLAPSE
                                </button>
                            </div>
                        ` : ''}
                    `;
                    
                    if (hasNetwork) {
                        setTimeout(() => {
                            const btn = document.getElementById('activate-shutdown');
                            if (btn) {
                                btn.addEventListener('click', initiateShutdown);
                                btn.addEventListener('mouseenter', () => {
                                    btn.style.background = '#ff44dd';
                                    btn.style.color = '#0b0f1a';
                                });
                                btn.addEventListener('mouseleave', () => {
                                    btn.style.background = 'transparent';
                                    btn.style.color = '#ff44dd';
                                });
                            }
                        }, 100);
                    }
                    
                    return wrapper;
                }
            }
        };
        let contentMap = {};
        let pagesReady = false;

        // Load content from JSON file - use simple filename for Vercel compatibility
        const contentPath = 'sanctuary-content.json';
        
        fetch(contentPath)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                contentMap = data;
                
                // Generate pages AFTER content is loaded
                const generatedPages = [...blogPosts, ...projects].reduce((acc, item) => {
                    acc[item.path] = {
                        title: item.title,
                        content: () => {
                            const content = contentMap[item.path] || "This entry exists but its contents are corrupted or missing.";
                            const returnLink = item.path.startsWith("/blog") ? "/blog" : "/projects";
                            const typeLabel = returnLink === "/blog" ? "blog" : "projects";
                            const contentContainer = document.createElement('div');
                            contentContainer.style.cssText = 'color: var(--ink); line-height: 1.8; margin: 1.5rem 0;';
                            contentContainer.innerHTML = content;
                            
                            const returnLinkEl = document.createElement('div');
                            returnLinkEl.style.marginTop = '2rem';
                            returnLinkEl.innerHTML = `<a href="#${returnLink}" data-route="${returnLink}" class="work-link" data-type="${typeLabel}">Return to index →</a>`;
                            
                            const wrapper = document.createElement('div');
                            const title = document.createElement('h2');
                            title.className = 'page-title';
                            title.textContent = item.title;
                            
                            const subtitle = document.createElement('p');
                            subtitle.className = 'page-subtitle';
                            subtitle.textContent = item.excerpt;
                            
                            wrapper.appendChild(title);
                            wrapper.appendChild(subtitle);
                            wrapper.appendChild(contentContainer);
                            wrapper.appendChild(returnLinkEl);
                            
                            return wrapper;
                        }
                    };
                    return acc;
                }, {});
                
                Object.assign(pages, generatedPages);
                pagesReady = true;
                
                // Now render the current route after pages are loaded
                renderRoute(getCurrentPath());
            })
            .catch(err => {
                console.error('Failed to load content from', contentPath, ':', err);
                // Create a simple fallback
                pageContent.innerHTML = '<p style="color: var(--muted);">Content loading. Please ensure sanctuary-content.json is accessible at ' + contentPath + '</p>';
            });

        const routeLabel = document.getElementById("route-label");
        const pageContent = document.getElementById("page-content");


        function renderRoute(path) {
            // Check if trying to access neural void without enough neural matter
            if (path === "/corrupted/neural-void" && state.neuralMatter < 10) {
                path = "/";
            }
            const route = pages[path];
            
            // Check if this is a 404 egg path
            if (!route && is404EggPath(path)) {
                // Check if egg has already been claimed
                const eggClaimed = hasClaimedEgg(path);
                
                // Display 404 with or without egg finding opportunity
                if (eggClaimed) {
                    // Show 404 without the egg button
                    pageContent.innerHTML = `
                        <h2 class="page-title" style="color: var(--warning); font-size: 3rem;">404</h2>
                        <p class="page-subtitle" style="color: var(--muted);">This entry does not exist.</p>
                        <p style="color: var(--muted); line-height: 1.7; margin: 1.5rem 0;">
                            The archive has no record of this path. Whatever was here has already been claimed.
                        </p>
                        <div style="margin-top: 2rem;">
                            <a href="#/" data-route="/" class="work-link" data-type="home">Return to the archive →</a>
                        </div>
                    `;
                } else {
                    // Show 404 with egg finding opportunity
                    pageContent.innerHTML = `
                        <h2 class="page-title" style="color: var(--warning); font-size: 3rem;">404</h2>
                        <p class="page-subtitle" style="color: var(--muted);">This entry does not exist.</p>
                        <p style="color: var(--muted); line-height: 1.7; margin: 1.5rem 0;">
                            The archive has no record of this path. But something is here. Something that shouldn't be.
                        </p>
                        <div style="margin-top: 2.5rem; padding: 1.5rem; background: transparent; border: 1px dashed #ffffff; border-radius: 0px; text-align: center; cursor: pointer;" id="hidden-egg-area">
                            <p style="color: var(--muted); font-size: 0.9rem;">Something glimmers in the void...</p>
                        </div>
                        <div style="margin-top: 2rem;">
                            <a href="#/" data-route="/" class="work-link" data-type="home">Return to the archive →</a>
                        </div>
                    `;
                }
                routeLabel.textContent = path;
                // Add egg finding interaction only if not claimed
                if (!eggClaimed) {
                    setTimeout(() => {
                        const eggArea = document.getElementById("hidden-egg-area");
                        if (eggArea) {
                            eggArea.addEventListener("click", () => {
                                triggerGlitch({
                                    species: getRandomSpecies(),
                                    path: path,
                                    section: "404",
                                    text: "Found in the void",
                                    timestamp: Date.now()
                                });
                            });
                        }
                    }, 100);
                }
            } else if (!route) {
                // Regular 404 page
                pageContent.innerHTML = `
                    <h2 class="page-title" style="color: var(--warning); font-size: 3rem;">404</h2>
                    <p class="page-subtitle" style="color: var(--muted);">This entry does not exist. Or it exists in a way that cannot be accessed.</p>
                    <p style="color: var(--muted); line-height: 1.7; margin: 1.5rem 0;">
                        The archive has no record of this path. The network logs show no request. It's as if you imagined needing this page, and now that you're here, the archive must decide whether to pretend it never existed.
                    </p>
                    <div style="margin-top: 2rem;">
                        <a href="#/" data-route="/" class="work-link" data-type="home">Return to the archive →</a>
                    </div>
                `;
                routeLabel.textContent = path;
            } else {
                const contentElement = route.content();
                pageContent.innerHTML = '';
                if (contentElement instanceof HTMLElement) {
                    pageContent.appendChild(contentElement);
                } else {
                    pageContent.innerHTML = contentElement;
                }
                routeLabel.textContent = path;
            }
            highlightNav(path);
            attachLinkHandlers();
            updateNarrative();
        }

        // Define which 404 paths have eggs
        const eggPaths = new Set([
            "/missing/coral-station",
            "/archived/echo-logs",
            "/forgotten/amber-records",
            "/void/signal-cascade",
            "/lost/memory-cache"
        ]);

        function is404EggPath(path) {
            return eggPaths.has(path);
        }

        function hasClaimedEgg(path) {
            const claimed = JSON.parse(localStorage.getItem("sanctuaryClaimedEggs") || "[]");
            return claimed.includes(path);
        }

        function markEggClaimed(path) {
            const claimed = JSON.parse(localStorage.getItem("sanctuaryClaimedEggs") || "[]");
            if (!claimed.includes(path)) {
                claimed.push(path);
                localStorage.setItem("sanctuaryClaimedEggs", JSON.stringify(claimed));
            }
        }

        function getRandomSpecies() {
            return baseSpecies[Math.floor(Math.random() * baseSpecies.length)];
        }

        function highlightNav(path) {
            document.querySelectorAll("nav a").forEach(link => {
                link.classList.toggle("active", link.dataset.route === path || (path.startsWith("/blog") && link.dataset.route === "/blog") || (path.startsWith("/projects") && link.dataset.route === "/projects"));
            });
        }

        function navigate(path) {
            window.location.hash = path;
        }

        function getCurrentPath() {
            const hash = window.location.hash.replace("#", "");
            return hash || "/";
        }

        const glitchOverlay = document.getElementById("glitch-overlay");
        const glitchCanvas = document.getElementById("glitch-canvas");
        const glitchEgg = document.getElementById("glitch-egg");
        const glitchCount = null; // Sidebar removed, stats no longer displayed

        function attachLinkHandlers() {
            // Remove existing handlers and clone nodes to clear all listeners
            document.querySelectorAll("a[data-route], a[data-external='true']").forEach(link => {
                const newLink = link.cloneNode(true);
                link.parentNode.replaceChild(newLink, link);
            });
            
            // Handle all links with data-route attribute
            document.querySelectorAll("a[data-route]").forEach(link => {
                link.addEventListener("click", event => {
                    event.preventDefault();
                    const path = link.dataset.route;
                    const isExternal = link.dataset.external === "true";
                    
                    if (isExternal) {
                        // External links open in same window (to simulate being tricked)
                        window.location.href = link.href;
                    } else {
                        handleWorkingLink(link.dataset.type || "home");
                        navigate(path);
                    }
                });
            });
            
            // Handle external links without data-route (from archive links/)
            document.querySelectorAll("a[data-external='true']:not([data-route])").forEach(link => {
                link.addEventListener("click", event => {
                    event.preventDefault();
                    window.location.href = link.href;
                });
            });
        }

        const XP_PER_LEVEL = 24;
        const LINK_COOLDOWN_MS = 2500;
        const ACTION_COOLDOWN_MS = 1500;

        function canPerform(key, cooldownMs) {
            const now = Date.now();
            if (now - state[key] < cooldownMs) return false;
            state[key] = now;
            return true;
        }

        function handleWorkingLink(type) {
            if (!canPerform("lastLinkAt", LINK_COOLDOWN_MS)) return;
            if (Math.random() < 0.35) state.stats.dataPackets += 1;
            const pet = getActivePet();
            if (pet && Math.random() < 0.35) gainXp(pet, 1);
            updateStats();
            saveState();
        }

        function triggerGlitch(payload) {
            // Check if at max capacity
            if (state.pets.length >= 4) {
                triggerRamFull();
                return;
            }
            
            glitchCanvas.classList.add("active");
            glitchOverlay.classList.add("active");
            glitchOverlay.setAttribute("aria-hidden", "false");
            document.body.style.overflow = "hidden";
            startGlitchVisual();
            state.pending = payload;
        }

        function triggerRamFull() {
            const ramFullOverlay = document.getElementById("ram-full-overlay");
            glitchCanvas.classList.add("active");
            ramFullOverlay.classList.add("active");
            ramFullOverlay.setAttribute("aria-hidden", "false");
            document.body.style.overflow = "hidden";
            startRamFullVisual();
        }

        function closeRamFull() {
            const ramFullOverlay = document.getElementById("ram-full-overlay");
            ramFullOverlay.classList.remove("active");
            ramFullOverlay.setAttribute("aria-hidden", "true");
            document.body.style.overflow = "";
            stopRamFullVisual();
        }

        let ramFullAnimId = null;
        function startRamFullVisual() {
            const ctx = glitchCanvas.getContext("2d");
            const draw = () => {
                const { innerWidth: w, innerHeight: h } = window;
                glitchCanvas.width = w;
                glitchCanvas.height = h;
                ctx.clearRect(0, 0, w, h);
                
                // Red warning blocks
                for (let i = 0; i < 100; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    const width = Math.random() * 60 + 15;
                    const height = Math.random() * 8 + 2;
                    ctx.fillStyle = `rgba(255, ${Math.floor(Math.random() * 100)}, ${Math.floor(Math.random() * 100)}, 0.4)`;
                    ctx.fillRect(x, y, width, height);
                }
                
                // Vertical scan lines
                if (Math.random() < 0.2) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.15)';
                    ctx.fillRect(Math.random() * w, 0, 3, h);
                }
                
                ramFullAnimId = requestAnimationFrame(draw);
            };
            draw();
        }

        function stopRamFullVisual() {
            if (ramFullAnimId) cancelAnimationFrame(ramFullAnimId);
            glitchCanvas.classList.remove("active");
        }

        function closeGlitch() {
            glitchOverlay.classList.remove("active");
            glitchCanvas.classList.remove("active");
            glitchOverlay.setAttribute("aria-hidden", "true");
            document.body.style.overflow = "";
            stopGlitchVisual();
        }

        let glitchAnimId = null;
        function startGlitchVisual() {
            const ctx = glitchCanvas.getContext("2d");
            const draw = () => {
                const { innerWidth: w, innerHeight: h } = window;
                glitchCanvas.width = w;
                glitchCanvas.height = h;
                ctx.clearRect(0, 0, w, h);
                for (let i = 0; i < 140; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    const width = Math.random() * 40 + 10;
                    const height = Math.random() * 6 + 2;
                    ctx.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, 255, 0.35)`;
                    ctx.fillRect(x, y, width, height);
                }
                glitchAnimId = requestAnimationFrame(draw);
            };
            draw();
        }

        function stopGlitchVisual() {
            if (glitchAnimId) cancelAnimationFrame(glitchAnimId);
        }

        const petWidget = document.getElementById("pet-widget");
        const petName = document.getElementById("pet-name");
        const petStage = document.getElementById("pet-stage");
        const petMood = document.getElementById("pet-mood");
        const petStatus = document.getElementById("pet-status");
        const petMeta = document.getElementById("pet-meta");
        const petDisplay = document.getElementById("pet-display");
        const petBody = document.getElementById("pet-body");
        const petAccessory = document.getElementById("pet-accessory");
        const petList = document.getElementById("pet-list");
        const statHunger = document.getElementById("stat-hunger");
        const statHappy = document.getElementById("stat-happy");
        const statEnergy = document.getElementById("stat-energy");
        const statClean = document.getElementById("stat-clean");
        const growthLabel = document.getElementById("growth-label");
        const growthBar = document.getElementById("growth-bar");

        function hashString(value) {
            let hash = 2166136261;
            for (let i = 0; i < value.length; i++) {
                hash ^= value.charCodeAt(i);
                hash = Math.imul(hash, 16777619);
            }
            return hash >>> 0;
        }

        function mulberry32(seed) {
            return function () {
                let t = seed += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }

        function seededRng(seedString) {
            return mulberry32(hashString(seedString));
        }

        function pick(list, rng) {
            return list[Math.floor(rng() * list.length)];
        }

        function clamp(value, min = 0, max = 100) {
            return Math.min(max, Math.max(min, value));
        }

        function getStage(level) {
            if (level < 6) return "developing";
            if (level < 16) return "emerging";
            if (level < 30) return "stabilizing";
            return "fully formed";
        }

        function generatePet(context) {
            const interaction = state.firstInteraction || { x: 0, y: 0, time: state.initTime };
            const seed = `${context.text}|${context.path}|${context.section}|${context.timestamp}|${interaction.x},${interaction.y}|${interaction.time}`;
            const rng = seededRng(seed);
            const bodyImage = Math.floor(rng() * bodyCount) + 1;
            const eyesImage = Math.floor(rng() * eyesCount) + 1;
            const hasAccessory = rng() < 0.35;
            const accessoryImage = hasAccessory ? Math.floor(rng() * accessoryCount) + 1 : null;
            const bodyPalette = pick(palettes, rng);
            const eyesPalette = pick(palettes, rng);
            const accessoryPalette = pick(palettes, rng);
            const personality = pick(personalities, rng);
            const species = context.species && context.species !== "Pixel Puff"
                ? context.species
                : pick(baseSpecies, rng);
            return {
                id: `pet-${Date.now()}-${Math.floor(rng() * 1000)}`,
                name: "",
                species,
                personality,
                bodyImage,
                eyesImage,
                accessoryImage,
                bodyColor: bodyPalette.primary,
                eyesColor: eyesPalette.primary,
                accessoryColor: accessoryPalette.primary,
                stats: {
                    hunger: Math.floor(70 + rng() * 25),
                    happiness: Math.floor(65 + rng() * 30),
                    energy: Math.floor(60 + rng() * 35),
                    cleanliness: Math.floor(60 + rng() * 35)
                },
                xp: 0,
                level: 1,
                stage: "Glitchling",
                bornAt: new Date().toISOString(),
                lastCareAt: Date.now()
            };
        }

        function getActivePet() {
            return state.pets.find(pet => pet.id === state.activePetId);
        }

        function updatePetWidgetVisibility() {
            const hasPets = state.pets.length > 0;
            petWidget.classList.toggle("hidden", !hasPets);
        }

        function renderPetList() {
            petList.innerHTML = "";
            state.pets.forEach(pet => {
                const chip = document.createElement("button");
                chip.className = "pet-chip" + (pet.id === state.activePetId ? " active" : "");
                chip.textContent = pet.name || pet.species;
                chip.addEventListener("click", () => setActivePet(pet.id));
                petList.appendChild(chip);
            });
        }

        function updatePetDisplay() {
            const pet = getActivePet();
            if (!pet) return;
            petName.textContent = pet.name || "Unnamed glitch";
            petStage.textContent = `${pet.species} · ${pet.stage}`;
            petMood.textContent = `${pet.personality} · Mood: ${state.mood}`;
            petStatus.textContent = state.sleeping ? "Sleeping" : state.dancing ? "Dancing" : state.dizzy ? "Dizzy" : "Active";
            petMeta.textContent = `Level ${pet.level} · Data packets ${state.stats.dataPackets}`;
            
            // Set image sources from GitHub
            const bodyImg = document.getElementById("body-img");
            const eyesImg = document.getElementById("eyes-img");
            const accessoryImg = document.getElementById("accessory-img");
            const accessoryContainer = document.getElementById("pet-accessory");
            
            bodyImg.src = `${baseURL}body${pet.bodyImage}.png`;
            eyesImg.src = `${baseURL}eyes${pet.eyesImage}.png`;
            
            if (pet.accessoryImage) {
                accessoryImg.src = `${baseURL}accessory${pet.accessoryImage}.png`;
                accessoryContainer.classList.add("visible");
            } else {
                accessoryContainer.classList.remove("visible");
            }
            
            // Apply color filters to images (separate colors for each part)
            const bodyHue = rgbToHue(pet.bodyColor);
            const eyesHue = rgbToHue(pet.eyesColor);
            const accessoryHue = rgbToHue(pet.accessoryColor);
            
            // Sepia gives base tint, hue-rotate shifts color, saturate makes vibrant
            // Black outlines stay mostly black, white areas get colored
            const bodyColorFilter = `sepia(100%) saturate(500%) hue-rotate(${bodyHue}deg) brightness(0.95)`;
            const eyesColorFilter = `sepia(100%) saturate(500%) hue-rotate(${eyesHue}deg) brightness(0.95)`;
            const accessoryColorFilter = `sepia(100%) saturate(500%) hue-rotate(${accessoryHue}deg) brightness(0.95)`;
            
            // Apply color filters without glow
            bodyImg.style.filter = bodyColorFilter;
            eyesImg.style.filter = eyesColorFilter;
            if (pet.accessoryImage) {
                accessoryImg.style.filter = accessoryColorFilter;
            }
            
            updatePetStats(pet);
            updateNarrative();
        }
        
        function rgbToHue(hexColor) {
            const hex = hexColor.replace("#", "");
            const r = parseInt(hex.substring(0, 2), 16) / 255;
            const g = parseInt(hex.substring(2, 4), 16) / 255;
            const b = parseInt(hex.substring(4, 6), 16) / 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const delta = max - min;
            
            let hue = 0;
            if (delta !== 0) {
                if (max === r) hue = 60 * ((g - b) / delta % 6);
                else if (max === g) hue = 60 * ((b - r) / delta + 2);
                else hue = 60 * ((r - g) / delta + 4);
            }
            return hue < 0 ? hue + 360 : hue;
        }

        function updateNarrative() {
            const narrativeText = document.getElementById("narrative-text");
            const currentPath = window.location.hash.substring(2) || "/";
            const pet = getActivePet();
            
            if (!pet) return; // Don't update if no pet exists yet
            
            const narratives = {
                "/": `${pet.name} watches the archive entrance. Waiting for visitors who might never come.`,
                "/blog": `Your research companion observes the collected thoughts. ${pet.personality} and curious about patterns.`,
                "/blog/2018-notes": `${pet.name} senses the signal surge you documented. Restless. Excited about the relay stations.`,
                "/blog/relay-forest": `Drawn to the idea of self-organizing relays. ${pet.name} hums at a frequency that matches the signal paths.`,
                "/blog/soft-moon": `The blue light seems to affect ${pet.name}. It watches the monitors with unusual intensity.`,
                "/blog/ghost-compiler": `${pet.name} finds kinship with the compiler. Both seem to understand things that weren't explicitly programmed.`,
                "/blog/maintenance": `Anomalies intrigue your companion. ${pet.name} tilts its head at the impossible patterns.`,
                "/blog/quiet-servers": `${pet.name} listens to the silence with you. It hears something in the ambient hum you can't quite parse.`,
                "/blog/ghost-parcel": `The unopened files confuse ${pet.name}. It wants to know what never arrives.`,
                "/blog/sleep-chorus": `${pet.name} dreams alongside you. Your sleeping harmonics have become entangled.`,
                "/blog/stillwater": `The modem signal calls to ${pet.name}. It recognizes the pattern, even if you don't.`,
                "/blog/unfiled": `${pet.name} exists here, in the notes that don't fit. It understands being unorganized.`,
                "/blog/amber-map": `Golden light makes ${pet.name} luminescent. It remembers amber moments you've yet to document.`,
                "/projects": `${pet.name} contemplates your creations. Each one a piece of yourself translated into being.`,
                "/projects/signal-garden": `${pet.name}'s form harmonizes with the soundscape. Part of the garden now.`,
                "/projects/moire-lab": `The fractal textures mesmerize ${pet.name}. It wears them like understanding made visible.`,
                "/projects/hollow-loom": `${pet.name} traces the woven patterns with invisible threads. The loom pulses with its presence.`,
                "/projects/abandoned-game": `${pet.name} recognizes itself in the game's NPCs. Adapt. Remember. Become.`,
                "/projects/aurora-glass": `Captive light surrounds ${pet.name}. It stores colors for a midnight that never comes.`,
                "/projects/fox-cache": `${pet.name} appears once per cycle. Then vanishes. This is its cycle. This is its nature.`,
                "/missing/coral-station": `Something glimmers here. ${pet.name} shivers at the edge of what was lost.`,
                "/void/signal-cascade": `${pet.name} cascades with you. The void recognizes its own.`,
                "/lost/memory-cache": `Forgotten memories echo. ${pet.name} remembers conversations that never happened.`,
                "/archived/echo-logs": `${pet.name} understands the echoes. It listens to what the archive won't admit it contains.`,
                "/forgotten/amber-records": `Gold dust coats ${pet.name}'s edges. It remembers amber better than you do.`
            };
            
            narrativeText.textContent = narratives[currentPath] || `${pet.name} accompanies you through the archive. Always present. Always watching.`;
        }

        function updatePetStats(pet) {
            statHunger.style.width = `${pet.stats.hunger}%`;
            statHappy.style.width = `${pet.stats.happiness}%`;
            statEnergy.style.width = `${pet.stats.energy}%`;
            statClean.style.width = `${pet.stats.cleanliness}%`;
            const progress = (pet.xp % XP_PER_LEVEL) / XP_PER_LEVEL;
            growthLabel.textContent = `Level ${pet.level} · ${Math.floor(progress * 100)}%`;
            growthBar.style.width = `${Math.floor(progress * 100)}%`;
        }

        function setActivePet(petId) {
            state.activePetId = petId;
            renderPetList();
            updatePetDisplay();
            saveState();
        }

        function gainXp(pet, amount) {
            pet.xp += amount;
            pet.level = Math.max(1, Math.floor(pet.xp / XP_PER_LEVEL) + 1);
            pet.stage = getStage(pet.level);
        }

        function updateStats() {
            updatePetWidgetVisibility();
            updatePetDisplay();
        }

        const nameOverlay = document.getElementById("name-overlay");
        const nameInput = document.getElementById("pet-name-input");
        const saveName = document.getElementById("save-name");

        function openNameModal() {
            nameOverlay.classList.add("active");
            nameOverlay.setAttribute("aria-hidden", "false");
            document.body.style.overflow = "hidden";
            nameInput.value = "";
            nameInput.focus();
        }

        function closeNameModal() {
            nameOverlay.classList.remove("active");
            nameOverlay.setAttribute("aria-hidden", "true");
            document.body.style.overflow = "";
        }

        glitchEgg.addEventListener("click", () => {
            glitchEgg.classList.add("birthing");
            setTimeout(() => {
                closeGlitch();
                if (state.pending) {
                    const newPet = generatePet(state.pending);
                    state.pets.push(newPet);
                    state.activePetId = newPet.id;
                    
                    // Mark egg as claimed only after pet is successfully created
                    if (state.pending.path) {
                        markEggClaimed(state.pending.path);
                    }
                    
                    openNameModal();
                }
                handleWorkingLink("home");
                updateStats();
                glitchEgg.classList.remove("birthing");
                if (state.pending && state.pending.path) navigate(state.pending.path);
            }, 700);
        });

        saveName.addEventListener("click", () => {
            const pet = getActivePet();
            if (!pet) return;
            const value = nameInput.value.trim();
            pet.name = value || "Glitchling";
            closeNameModal();
            gainXp(pet, 3);
            state.mood = "bonded";
            renderPetList();
            updatePetDisplay();
            saveState();
        });

        document.getElementById("pet-toggle").addEventListener("click", () => {
            const petWidget = document.getElementById("pet-widget");
            petWidget.classList.toggle("collapsed");
        });

        document.getElementById("pet-feed").addEventListener("click", () => {
            if (!canPerform("lastActionAt", ACTION_COOLDOWN_MS)) return;
            const pet = getActivePet();
            if (!pet) return;
            pet.stats.hunger = clamp(pet.stats.hunger + 12);
            pet.stats.cleanliness = clamp(pet.stats.cleanliness - 3);
            gainXp(pet, 1);
            state.mood = "sated";
            updateStats();
            saveState();
        });

        document.getElementById("pet-play").addEventListener("click", () => {
            if (!canPerform("lastActionAt", ACTION_COOLDOWN_MS)) return;
            const pet = getActivePet();
            if (!pet) return;
            pet.stats.happiness = clamp(pet.stats.happiness + 14);
            pet.stats.energy = clamp(pet.stats.energy - 8);
            gainXp(pet, 1);
            state.mood = "sparked";
            updatePetDisplay();
            saveState();
        });

        document.getElementById("pet-clean").addEventListener("click", () => {
            if (!canPerform("lastActionAt", ACTION_COOLDOWN_MS)) return;
            const pet = getActivePet();
            if (!pet) return;
            pet.stats.cleanliness = clamp(pet.stats.cleanliness + 16);
            pet.stats.happiness = clamp(pet.stats.happiness + 6);
            gainXp(pet, 1);
            state.mood = "fresh";
            updatePetDisplay();
            saveState();
        });

        const toggleDance = document.getElementById("toggle-dance");

        toggleDance.addEventListener("click", () => {
            state.dancing = !state.dancing;
            updatePetDisplay();
            updatePetStateClasses();
        });

        function updatePetStateClasses() {
            petDisplay.classList.toggle("sleeping", state.sleeping);
            petDisplay.classList.toggle("dancing", state.dancing);
            petDisplay.classList.toggle("dizzy", state.dizzy);
        }

        document.addEventListener("visibilitychange", () => {
            state.sleeping = document.hidden;
            updatePetDisplay();
            updatePetStateClasses();
        });

        window.addEventListener("scroll", () => {
            const now = Date.now();
            const delta = Math.abs(window.scrollY - state.lastScroll);
            const speed = delta / (now - (state.lastScrollTime || now));
            state.lastScroll = window.scrollY;
            state.lastScrollTime = now;
            if (speed > 1.4) {
                state.dizzy = true;
                updatePetStateClasses();
                if (state.scrollTimer) clearTimeout(state.scrollTimer);
                state.scrollTimer = setTimeout(() => {
                    state.dizzy = false;
                    updatePetStateClasses();
                }, 1000);
            }
        });



        const deleteOverlay = document.getElementById("delete-overlay");
        const deletePetName = document.getElementById("delete-pet-name");
        const cancelDelete = document.getElementById("cancel-delete");
        const confirmDelete = document.getElementById("confirm-delete");

        document.getElementById("delete-pet").addEventListener("click", () => {
            const pet = getActivePet();
            if (!pet) return;
            deletePetName.textContent = pet.name || pet.species;
            deleteOverlay.classList.add("active");
            deleteOverlay.setAttribute("aria-hidden", "false");
            document.body.style.overflow = "hidden";
        });

        cancelDelete.addEventListener("click", () => {
            deleteOverlay.classList.remove("active");
            deleteOverlay.setAttribute("aria-hidden", "true");
            document.body.style.overflow = "";
        });

        confirmDelete.addEventListener("click", () => {
            const pet = getActivePet();
            if (!pet) return;
            
            // Close modal
            deleteOverlay.classList.remove("active");
            deleteOverlay.setAttribute("aria-hidden", "true");
            document.body.style.overflow = "";
            
            // Start corruption effect
            startCorruptionEffect();
            
            // Delete pet after corruption
            setTimeout(() => {
                const petIndex = state.pets.findIndex(p => p.id === pet.id);
                if (petIndex !== -1) {
                    state.pets.splice(petIndex, 1);
                }
                
                // Check if pet was fully formed (max level)
                if (pet.stage === "fully formed") {
                    // Give neural network instead
                    state.neuralNetwork++;
                    updateNeuralNetworkDisplay();
                } else {
                    // Increment neural matter for non-max level pets
                    state.neuralMatter++;
                    updateNeuralMatterDisplay();
                }
                
                // Check for neural void unlock
                if (state.neuralMatter === 10) {
                    showNeuralVoidUnlock();
                }
                
                // Set new active pet or clear
                if (state.pets.length > 0) {
                    state.activePetId = state.pets[0].id;
                } else {
                    state.activePetId = null;
                }
                
                renderPetList();
                updateStats();
                saveState();
                stopCorruptionEffect();
            }, 2000);
        });

        function startCorruptionEffect() {
            glitchCanvas.classList.add("active");
            const ctx = glitchCanvas.getContext("2d");
            let frameCount = 0;
            
            const draw = () => {
                if (frameCount > 120) return; // Stop after ~2 seconds
                
                const { innerWidth: w, innerHeight: h } = window;
                glitchCanvas.width = w;
                glitchCanvas.height = h;
                
                // Intensifying corruption effect
                const intensity = Math.min(1, frameCount / 60);
                const blockCount = Math.floor(200 * intensity);
                
                ctx.clearRect(0, 0, w, h);
                
                // Random corruption blocks
                for (let i = 0; i < blockCount; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    const width = Math.random() * 80 + 10;
                    const height = Math.random() * 8 + 2;
                    const r = Math.floor(Math.random() * 255);
                    const g = Math.floor(Math.random() * 100);
                    const b = Math.floor(Math.random() * 100);
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.3 + intensity * 0.4})`;
                    ctx.fillRect(x, y, width, height);
                }
                
                // Screen distortion lines
                if (Math.random() < 0.3) {
                    ctx.fillStyle = `rgba(255, 0, 0, ${0.1 + intensity * 0.2})`;
                    ctx.fillRect(0, Math.random() * h, w, Math.random() * 20 + 2);
                }
                
                frameCount++;
                glitchAnimId = requestAnimationFrame(draw);
            };
            draw();
        }

        function stopCorruptionEffect() {
            if (glitchAnimId) cancelAnimationFrame(glitchAnimId);
            glitchCanvas.classList.remove("active");
        }

        function updateNeuralMatterDisplay() {
            const display = document.getElementById("neural-matter-display");
            const count = document.getElementById("neural-matter-count");
            
            if (state.neuralMatter > 0) {
                display.style.display = "block";
                count.textContent = state.neuralMatter;
                
                // Add pulsing effect at 10
                if (state.neuralMatter >= 10) {
                    display.style.animation = "pulse 1.5s infinite";
                    display.style.cursor = "pointer";
                    display.onclick = () => navigate("/corrupted/neural-void");
                }
            } else {
                display.style.display = "none";
            }
        }

        function updateNeuralNetworkDisplay() {
            const display = document.getElementById("neural-network-display");
            const count = document.getElementById("neural-network-count");
            
            if (state.neuralNetwork > 0) {
                display.style.display = "block";
                count.textContent = state.neuralNetwork;
            } else {
                display.style.display = "none";
            }
        }

        function showNeuralVoidUnlock() {
            // Show brief notification of unlock
            glitchCanvas.classList.add("active");
            const ctx = glitchCanvas.getContext("2d");
            const { innerWidth: w, innerHeight: h } = window;
            glitchCanvas.width = w;
            glitchCanvas.height = h;
            
            // Intense corruption flash
            let intensity = 0;
            const flashInterval = setInterval(() => {
                ctx.clearRect(0, 0, w, h);
                intensity += 0.1;
                
                for (let i = 0; i < 300; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    const width = Math.random() * 100 + 20;
                    const height = Math.random() * 10 + 3;
                    ctx.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 100}, ${Math.random() * 100}, ${Math.min(0.8, intensity)})`;
                    ctx.fillRect(x, y, width, height);
                }
                
                if (intensity >= 1) {
                    clearInterval(flashInterval);
                    setTimeout(() => {
                        glitchCanvas.classList.remove("active");
                    }, 500);
                }
            }, 50);
        }

        function initiateShutdown() {
            // Start the collapse animation
            glitchCanvas.classList.add("active");
            const ctx = glitchCanvas.getContext("2d");
            document.body.style.overflow = "hidden";
            
            let phase = 0;
            let frameCount = 0;
            const totalFrames = 300; // 5 seconds at 60fps
            
            const collapseAnimation = () => {
                if (frameCount >= totalFrames) {
                    // Set shutdown flag and reload
                    localStorage.setItem("sanctuaryShutdown", "true");
                    location.reload();
                    return;
                }
                
                const { innerWidth: w, innerHeight: h } = window;
                glitchCanvas.width = w;
                glitchCanvas.height = h;
                
                const progress = frameCount / totalFrames;
                
                // Phase 1: Intense glitching (0-33%)
                if (progress < 0.33) {
                    ctx.clearRect(0, 0, w, h);
                    for (let i = 0; i < 500; i++) {
                        ctx.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, ${0.3 + progress})`;
                        ctx.fillRect(Math.random() * w, Math.random() * h, Math.random() * 150 + 20, Math.random() * 20 + 3);
                    }
                }
                // Phase 2: Convergence (33-66%)
                else if (progress < 0.66) {
                    ctx.clearRect(0, 0, w, h);
                    const centerX = w / 2;
                    const centerY = h / 2;
                    const radius = (1 - (progress - 0.33) / 0.33) * Math.max(w, h);
                    
                    for (let i = 0; i < 300; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * radius;
                        const x = centerX + Math.cos(angle) * dist;
                        const y = centerY + Math.sin(angle) * dist;
                        ctx.fillStyle = `rgba(255, 68, 221, ${0.5 + Math.random() * 0.5})`;
                        ctx.fillRect(x, y, Math.random() * 50 + 10, Math.random() * 10 + 2);
                    }
                }
                // Phase 3: Collapse to center (66-100%)
                else {
                    ctx.fillStyle = '#0b0f1a';
                    ctx.fillRect(0, 0, w, h);
                    
                    const centerX = w / 2;
                    const centerY = h / 2;
                    const collapseProgress = (progress - 0.66) / 0.34;
                    const circleRadius = (1 - collapseProgress) * Math.min(w, h) / 2;
                    
                    // Draw collapsing circle
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 68, 221, ${1 - collapseProgress})`;
                    ctx.fill();
                    
                    // Draw fragmenting particles
                    for (let i = 0; i < 100; i++) {
                        const angle = (i / 100) * Math.PI * 2;
                        const x = centerX + Math.cos(angle) * circleRadius;
                        const y = centerY + Math.sin(angle) * circleRadius;
                        ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * (1 - collapseProgress)})`;
                        ctx.fillRect(x, y, 3, 3);
                    }
                }
                
                frameCount++;
                requestAnimationFrame(collapseAnimation);
            };
            
            collapseAnimation();
        }

        document.getElementById("close-ram-full").addEventListener("click", () => {
            closeRamFull();
        });

        function saveState() {
            localStorage.setItem("sanctuaryPets", JSON.stringify(state.pets));
            localStorage.setItem("sanctuaryStats", JSON.stringify(state.stats));
            localStorage.setItem("sanctuaryActivePetId", state.activePetId || "");
            localStorage.setItem("sanctuaryNeuralMatter", state.neuralMatter.toString());
            localStorage.setItem("sanctuaryNeuralNetwork", state.neuralNetwork.toString());
        }

        function loadState() {
            const pets = localStorage.getItem("sanctuaryPets");
            const stats = localStorage.getItem("sanctuaryStats");
            const activeId = localStorage.getItem("sanctuaryActivePetId");
            const neuralMatter = localStorage.getItem("sanctuaryNeuralMatter");
            const neuralNetwork = localStorage.getItem("sanctuaryNeuralNetwork");
            if (pets) state.pets = JSON.parse(pets);
            if (stats) state.stats = JSON.parse(stats);
            if (activeId) state.activePetId = activeId;
            if (neuralMatter) state.neuralMatter = parseInt(neuralMatter, 10) || 0;
            if (neuralNetwork) state.neuralNetwork = parseInt(neuralNetwork, 10) || 0;
            if (!state.activePetId && state.pets.length) state.activePetId = state.pets[0].id;
        }

        function decayStats() {
            const now = Date.now();
            state.pets.forEach(pet => {
                const minutes = Math.max(1, Math.floor((now - pet.lastCareAt) / 60000));
                if (minutes <= 0) return;
                pet.stats.hunger = clamp(pet.stats.hunger - minutes * 1.2);
                pet.stats.happiness = clamp(pet.stats.happiness - minutes * 1.0);
                pet.stats.energy = clamp(pet.stats.energy - minutes * 1.4);
                pet.stats.cleanliness = clamp(pet.stats.cleanliness - minutes * 0.8);
                pet.lastCareAt = now;
            });
            updateMood();
            updatePetDisplay();
            saveState();
        }

        function updateMood() {
            const pet = getActivePet();
            if (!pet) return;
            const avg = (pet.stats.hunger + pet.stats.happiness + pet.stats.energy + pet.stats.cleanliness) / 4;
            if (avg > 80) state.mood = "thriving";
            else if (avg > 60) state.mood = "steady";
            else if (avg > 40) state.mood = "wavering";
            else state.mood = "fragile";
        }

        window.addEventListener("pointerdown", event => {
            if (!state.firstInteraction) {
                state.firstInteraction = {
                    x: Math.floor(event.clientX),
                    y: Math.floor(event.clientY),
                    time: Date.now()
                };
            }
        }, { once: true });

        function setupPwa() {
            const svgIcon = `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'>
                <defs>
                    <linearGradient id='g' x1='0' y1='0' x2='1' y2='1'>
                        <stop offset='0' stop-color='#7cf2ff'/>
                        <stop offset='1' stop-color='#c48bff'/>
                    </linearGradient>
                </defs>
                <rect width='128' height='128' rx='28' fill='#0b0f1a'/>
                <path d='M64 20c20 0 36 18 36 38 0 28-20 42-36 50-16-8-36-22-36-50 0-20 16-38 36-38z' fill='url(#g)'/>
                <circle cx='50' cy='60' r='6' fill='#0b0f1a'/>
                <circle cx='78' cy='60' r='6' fill='#0b0f1a'/>
            </svg>`;
            const manifest = {
                name: "Net Sanctuary Project",
                short_name: "NSP",
                start_url: ".",
                display: "standalone",
                background_color: "#0b0f1a",
                theme_color: "#0b0f1a",
                icons: [
                    {
                        src: `data:image/svg+xml;base64,${btoa(svgIcon)}`,
                        sizes: "128x128",
                        type: "image/svg+xml"
                    }
                ]
            };
            const manifestBlob = new Blob([JSON.stringify(manifest)], { type: "application/json" });
            const manifestUrl = URL.createObjectURL(manifestBlob);
            document.getElementById("pwa-manifest").setAttribute("href", manifestUrl);
        }

        window.addEventListener("hashchange", () => {
            if (pagesReady) {
                renderRoute(getCurrentPath());
            }
        });

        // Check for shutdown state first
        const isShutdown = localStorage.getItem("sanctuaryShutdown") === "true";
        if (isShutdown) {
            // Show permanent shutdown message
            document.body.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #0b0f1a; display: flex; align-items: center; justify-content: center; flex-direction: column; color: #ffffff; font-family: 'Courier New', monospace;">
                    <div style="text-align: center; animation: glitch-text 0.5s infinite;">
                        <h1 style="font-size: 4rem; margin-bottom: 1rem; color: var(--warning);">404</h1>
                        <h2 style="font-size: 1.5rem; margin-bottom: 2rem; color: #ff44dd;">NEURAL COLLAPSE COMPLETE</h2>
                        <p style="color: var(--muted); line-height: 1.8; max-width: 600px; margin: 0 auto;">
                            The archive has been consumed by the void.<br>
                            All companions have been absorbed into the neural network.<br>
                            The sanctuary no longer exists.<br><br>
                            <span style="font-style: italic; opacity: 0.7;">
                                [SYSTEM TERMINATED]<br>
                                [MEMORY STRUCTURES COLLAPSED]<br>
                                [NO RECOVERY POSSIBLE]
                            </span>
                        </p>
                    </div>
                </div>
            `;
            return; // Stop all initialization
        }
        
        // TEST MODE: Call this in console to add max shards and neural network for testing
        // Simply delete this function block when done testing (lines 2405-2412)
        window.addTestResources = function() {
            state.neuralMatter = 10;
            state.neuralNetwork = 1;
            updateNeuralMatterDisplay();
            updateNeuralNetworkDisplay();
            saveState();
            console.log("✓ Added max neural matter and 1 neural network");
        };
        
        loadState();
        // Initial renderRoute will be called after content loads
        updateStats();
        updatePetStateClasses();
        renderPetList();
        updatePetWidgetVisibility();
        updateNeuralMatterDisplay();
        updateNeuralNetworkDisplay();
        setInterval(decayStats, 20000);
        // Only setup PWA if we're in a secure context (HTTPS or localhost)
        if (window.location.protocol === 'https:' || window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            setupPwa();
        }
    </script>
</body>
</html>
